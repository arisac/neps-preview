'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/neps-preview/assets/readme/init.html','title':"Init",'content':""});index.add({'id':1,'href':'/neps-preview/assets.html','title':"Assets",'content':""});index.add({'id':2,'href':'/neps-preview/neps/nep-0006.html','title':"Basic Token Standard (NRC-6)",'content':"Simple Summary #  A standard interface for tokens.\nAbstract #  The following standard allows for the implementation of a standard API for tokens within smart contracts. This standard provides basic functionality to transfer tokens, as well as allow tokens to be approved so they can be spent by another on-chain third party.\nMotivation #  A standard interface allows any tokens on NewChain to be re-used by other applications: from wallets to decentralized exchanges.\nSpecification #  Meta Data #     Item Description Behaviors/Properties     name Name of token    symbol Symbol of token    decimals decimals of Token    totalSupply Total supply of Token     Interaction / Functions #     Function Description Behaviors/Properties     transfer(recipient, amount) Moves amount tokens from the caller\u0026rsquo;s account to recipient    approve(spender, amount) Sets amount as the allowance of spender over the caller\u0026rsquo;s tokens    transferFrom(sender, recipient, amount) Moves amount tokens from sender to recipient    Query     balanceOf(account) Returns the amount of tokens owned by account    allowance(owner, spender) Returns the remaining number of tokens that spender is allowed to spend from owner    Events     Transfer(from, to, value) Emitted when value tokens are moved from one account (from) to another (to).    Approval(owner, spender, value) Emitted when the allowance of a spender for an owner is set by a call to {approve}     Rationale (optional) #  TBD\nTest Cases (optional) #  TBD\nImplementation (optional) #  interface INRC6 { /** * @dev Returns the amount of tokens in existence. */ function totalSupply() external view returns (uint256); /** * @dev Returns the amount of tokens owned by `account`. */ function balanceOf(address account) external view returns (uint256); /** * @dev Moves `amount` tokens from the caller\u0026#39;s account to `recipient`. * * Returns a boolean value indicating whether the operation succeeded. * * Emits a {Transfer} event. */ function transfer(address recipient, uint256 amount) external returns (bool); /** * @dev Returns the remaining number of tokens that `spender` will be * allowed to spend on behalf of `owner` through {transferFrom}. This is * zero by default. * * This value changes when {approve} or {transferFrom} are called. */ function allowance(address owner, address spender) external view returns (uint256); /** * @dev Sets `amount` as the allowance of `spender` over the caller\u0026#39;s tokens. * * Returns a boolean value indicating whether the operation succeeded. * * IMPORTANT: Beware that changing an allowance with this method brings the risk * that someone may use both the old and the new allowance by unfortunate * transaction ordering. One possible solution to mitigate this race * condition is to first reduce the spender\u0026#39;s allowance to 0 and set the * desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * * Emits an {Approval} event. */ function approve(address spender, uint256 amount) external returns (bool); /** * @dev Moves `amount` tokens from `sender` to `recipient` using the * allowance mechanism. `amount` is then deducted from the caller\u0026#39;s * allowance. * * Returns a boolean value indicating whether the operation succeeded. * * Emits a {Transfer} event. */ function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); /** * @dev Emitted when `value` tokens are moved from one account (`from`) to * another (`to`). * * Note that `value` may be zero. */ event Transfer(address indexed _from, address indexed _to, uint256 _value); /** * @dev Emitted when the allowance of a `spender` for an `owner` is set by * a call to {approve}. `value` is the new allowance. */ event Approval(address indexed _owner, address indexed _spender, uint256 _value); } References #   ERC-20 https://eips.ethereum.org/EIPS/eip-20  Copyright #  Copyright and related rights waived via CC0.\n"});index.add({'id':3,'href':'/neps-preview/neps/nep-0001.html','title':"Improvement to Newton Foundation reserved token release rules",'content':"Summary: #  In order to ensure the scarcity and reasonable liquidity of Newton tokens (NEW), based on the ideas and opinions of all parties, the following suggestions are put forth to modify the token release rules.\nDetails: #  The plan for Newton Foundation reserved token release as stated in the Newton White Paper V0.5 is that “1/2 of the total is immediately unlocked, while the rest will be unlocked 1/12 every month.” Through this NEP, it will be changed to “1/5 of the total is immediately released, while the rest will be unlocked 1/36 every month,” and published in the Newton White Paper V0.6.\nRelated materials: #   Newton White Paper: https://www.newtonproject.org/whitepaper/ Newton website: https://www.newtonproject.org/  "});index.add({'id':4,'href':'/neps-preview/neps/nep-0010.html','title':"Invoice Token Standard (NRC-10)",'content':"Simple Summary #  A standard interface for invoice token.\nAbstract #  The following standard allows for the implementation of a standard API for invoice token within smart contracts. This standard provides basic functionality to issue、reimburse and invalidate invoice token.\nMotivation #  A standard interface allows tax/invoice/financial applications to work with invoice token on NewChain. We provide for simple invoiceToken smart contracts as well as contracts that track an arbitrarily large number of invoice tokens.\nThe invoice token will curb malpractice and document forgery in taxation and simplify procedures.\nSpecification #  Meta Data #     Item Description Behaviors/Properties     Owner can take full control of contract deploy contract, add/remove addmin, set fee   Admin manage enterprise authorize/revoke enterprise   Enterprise manage token(Invoice) issue/reimburse/invalidate token   Fee issue token(invoice) fee uint ISSAC   FeeAddress fee withdrawal to this address    Invoice contains operatorAddress, sellerTaxNumber, buyerTaxNumber, operatorName, invoiceInfo, status, financial status: positive、negative(reversal)、blank cancellation、cancellation, financial: received、recorded    Interaction / Functions #     Function Description Behaviors/Properties     owner     addAdmin add admin to this contract permission: owner   removeAdmin remove admin from this contract permission: owner   setFee set issue fee，uint ISSAC permission: owner   setFeeAddress set issue fee withdrawal address permission: owner   withdraw withdrawal to feeAddress permission: owner   admin     authorize authorized _enterpriseAddress to join contract permission: admin   revoke revoke _enterpriseAddress from this contract permission: admin   enterprise     issue issue new token(Invoice) by msg.sender permission: enterprise   issueFrom issue new token(Invoice) by the approved address of the seller permission: enterprise   reimburse change Invoice financial status from received to recorded permission: enterprise   invalidate change Invoice status from positive to _newStatus permission: enterprise   setApprovalForAll enable or disable approval for a third party (\u0026ldquo;operator\u0026rdquo;) to manage all of msg.sender\u0026rsquo;s invoice token permission: enterprise   Query     totalSupply return issue invoices fee total    balanceOfSeller return sell invoices count    balanceOfBuyer return buy invoices count    tokenById return Invoice info    getFee return issue invoice fee    getFeeSum return contract revenue    getFeeBalance return contract balance    isApprovedForAll check is authorizationed    isExist check token is existed     Test Cases #  The reference implementation contains all the tests.\nImplementation #  pragma solidity ^0.5.0; interface INRC10{ ///////////////////////////////////////////////////  // function for owner //  ///////////////////////////////////////////////////  event AdminAdded(address _admin); function addAdmin (address _admin) external public onlyOwner; event AdminRemoved(address _admin); function removeAdmin (address _admin) external public onlyOwner; event SetFeeSeted(uint _fee); //set issue fee，uint ISSAC  function setFee(uint _fee) external public onlyOwner; event FeeAddressSeted(address _feeAddress); //set issue fee withdrawal address  function setFeeAddress(address payable _feeAddress) external public onlyOwner; event FeeAndFeeAddressSeted(uint _fee, address _feeAddress); function setFeeAndFeeAddress(uint _fee, address payable _feeAddress) external public onlyOwner; event WithdrawalSuccess(address indexed _to, uint _amount); //uint ISSAC  function withdraw(uint _withraw_amount) external public onlyOwner; ///////////////////////////////////////////////////  // function for admin //  ///////////////////////////////////////////////////  event AuthorizeSuccess(address _admin, address _enterpriseAddress, string _taxNumber); //authorized enterprise to join contract  function authorize (address _enterpriseAddress, string memory _taxNumber) external public; event RevokeSuccess(address _admin, address _enterpriseAddress); //revoke enterprise  function revoke (address _enterpriseAddress) external public; ///////////////////////////////////////////////////  // function for enterprise //  ///////////////////////////////////////////////////  event Issued(address _send, string _from, string _to, bytes32 _tokenId); //issue Invoice  function issue(string memory _to, bytes32 _tokenId, string memory _operatorName, string memory _invoiceInfo) external payable public; function issueFrom(string memory _from, string memory _to, bytes32 _tokenId, string memory _operatorName, string memory _invoiceInfo) external payable public; event ReimburseSuccess(address _enterprise, bytes32 _tokenId); function reimburse(bytes32 _tokenId) external public; event InvalidateSuccess(address _enterprise, bytes32 _tokenId, uint8 _newStatus); function invalidate(bytes32 _tokenId, uint8 _newStatus) external public; event ApprovalForAllSeted(address _from, address _operator, bool _approved); function setApprovalForAll(address _operator, bool _approved) external public; ///////////////////////////////////////////////////  // function for all //  ///////////////////////////////////////////////////  //return issue invoices total  function totalSupply() external public view returns (uint); //return sell invoices count  function balanceOfSeller(string memory _taxNumber) external public view returns (uint); // return buy invoices count  function balanceOfBuyer(string memory _taxNumber) external public view returns (uint); //return issue invoice fee, uint ISSAC  function getFee() external public view returns (uint); //return contract revenue，uint ISSAC  function getFeeSum() external public view returns (uint); //return contract balance，uint ISSAC  function getFeeBalance() external public view returns (uint); //return is authorizationed  function isApprovedForAll(address _owner, address _operator) external public view returns (bool); //return invoce info  function tokenById(bytes32 _tokenId) external public view returns; function isExist(bytes32 _tokenId) external public view returns (bool); } The reference implementation\nReferences #   ERC-721 Token Standard. https://eips.ethereum.org/EIPS/eip-721  Copyright #  Copyright and related rights waived via CC0.\n"});index.add({'id':5,'href':'/neps-preview/neps/nep-0023.html','title':"NEAT Backed Currency (NBC)",'content':"Simple Summary #   NEAT Backed Currency (NBC) is a kind of cryptographically secured currency following the design protocol of NEAT. The goal of this creation is the allow anyone to create a set of exchangeable, and divisible asset that can be securely exchanged using the platform provided by Newton Community. We used the term community, because the distributed security, must be backed by a community of infrastructure providers and a rather healthy exchange community. By sharing the same set of features and capabilities developed by the entire Newton Community (NC), the quality and functionalities of the \u0026ldquo;currency\u0026rdquo; of interest could leverage the engineering and community support that has been developed over the years.\nAbstract #  NEAT-based Currency (NBC), is a divisible kind of asset that can be used as a unit of exchangeable value, to be transferred between two accounts in a community of choice. This community must leverage certain set of cryptographically secure protocols, so that asset exchange can be conducted under the same level of cryptographic protection. To create a new currency for exchange in a chosen community, certain community identity management system, and its account management system must be in place. For now, we will assume that the participants will start with existing Newton ID and NewKYC account management system. So that they will enjoy the same level of security. More over, all NEAT-backed Currency should follow the requirement as mentioned below:\n A currency must be guaranteed by a collateral asset, controllable under a cryptographically protected system, The entire transaction history will leverage NewChain\u0026rsquo;s secure timestamping services, The initial participating accounts will only include NewID and NewKYC, The exchangeable asset (currency) identities must be conserved and immutable (Quantitative Easing NOT ALLOWED), The participation of asset exchange can be defined by the NBC issuers and participants. Univalence: the security and value of cryptographically protected asset is defined by a unifying technical parameters of the security system. When there is a large number of NBCs, individual NBC\u0026rsquo;s technical security risk can be isolated from the market value fluctuation of a specific currency.  Motivation #  There are many organizational or community governance tasks that requires certain scoring or asset distribution system. To construct a secure system takes both technical know how and a significant amount of financial investment. NBC provides a solution to allow a larger number of people to create a small pool of assets, and allow these assets to be exchanged between participating parties. To make this system generally useful, the goal of NBC is to isolate the value of exchangeable asset from external marketplace as much as possible. Participants should measure and assess the value of the currency, purely on the security features of the exchange system, and a common clock of all exchange activities. This isolation of value judgement will significantly broaden the use of NBC, and allows more people to adopt this infrastructure of their own use. We list a number of possible usecase scenarios to motivate the design.\nSoftware Implementation and Content Development Communities #  A key component of value in cooperative content development or software development, is not often not the financial incentives, but the timing of content presentation. If an open source community has a high rate of bug-fixing responses, the overall user satisfaction will increase, therefore improve the ecology of the software user community as a whole. Therefore, the key incentive structure is to have a indifferent time keeper, that registers and rewards contributors of content, that most quickly resolves the issue. In other words, the currency in the community is response time. Clearly, the market value of the response time should be validated by the actual trajectory of content/software adoption curve. Therefore, the issuance of currency can be grounded on that type of data. In other words, having a system that distribute rewards based on commonly observed data, not just temporary market arbitrage activities for some external assets, such as USDT or other highly liquid asset, will protect the essential value of a localized currency.\nCommunity Services #  To mobilize community services, it is often necessary to keep a regular tab on how many times or how often certain services is delivered. For those contributors who are most regularly, or most frequently serving the community, a system like NBC could be the ledger of the fragmented community activities. For example, garbage pick-up and food deliver could be measured based on their record of being on-time. NBC could serve this area in helping teams to manage the quality of service using a combination of secure time stamps and other verifiable data.\nPhysical Security and Social Gathering/Distancing Measures #  A critical feature of Newchain is its 3 second resolution in data blocks. This highly responsive data update rates, provide a reasonable mechanism to help monitor the physical states of certain assets and define values based on the data records. For example, high density presence of mobile phones in a certain location, could indicate the physical location has high commercial/advertisement values, or large social distance risks. Therefore, issuing a currency based on this rather objective and publicly observable data set, can offer a meaningful metric to define the value of physical presence in certain time slots. This kind of applications can be better supported by NBC, when assets or score keeping systems are bound to the high-resolution Newchain timestamps.\nOther Applications in generalized digital workflow #  Any social or economic applications that deal with value changing with time could use NBC to measure the value created or dissipated over time. By focusing on the causal possibilities of offering solutions across the reachable locations within Newton Community, any account could contribute to or benefit from the publication of the availability of physical services or digital content. The timing and causal relations between any events, could be written up as motivating programs that identify certain patterns of behavior and direct resources for that behavior. This general programming paradigm is often called policy design. NBC provides a general purpose platform to develop executable policies under one infrastructure.\nSpecification #  Initially NBC just need to define the name of the currency, the total amount of its exchangeable units, and the conditions of who and when certain participants can exchange the declared units. For the purpose of human cognitive load, NBC will not allow quantitative easing, or splitting or stock, in any NBC. To make certain asset having more divisible resolution, one can transfer all the asset into a new NBC. That means, this division will require a significant amount of participant to agree with such transfer. In any case, NBC should be simple, so that people know what they are getting into and what they will face into the future. Once certain asset transfer policy is issued for an NBC, all existing asset will follow the same policy from that point onward. So that all asset valuation will attain certain consistency in value exchange.\nSyntax and Semantics #  The issuance of NBC can follow the following procedure:\n   Step Essential Term Explanation     1 Initial State Identify an unused name in the NBC registry   2 Guaranteed Deposit Certain initiator deposits certain valuable asset for the initial offering of NBC.   3 Exit Policy A self-executing \u0026ldquo;smart contract\u0026rdquo; will be written for how to redistribute the division of deposited asset when the NBC must be dissolved.   4 Immutable Division Define a total number of divisions for the newly created NBC. This cannot be changed ever   5 Distribution Rights The account that deposited the initial asset will have the right to distribute the divisions as created.   6 Participation Rights A \u0026ldquo;smart contract\u0026rdquo;, or a list of conditions for who in the Newton Community can participate in the exchange.   7 Rights to Expand Properties Any participant can increase the deposit   8 Backward Compatibility Any NBC account has the right to continue cash out residual value based on current exchange rates or the Exit Policy    Deployment Procedures #  The creation of NBC should follow a conservative stance. The goal is not to quickly create many exchangeable assets, so that many people could quickly create many gambling pools. The goal is to create a series of highly secure and useful patterns for governance. Therefore, the following policies should be obeyed to reduce, and ideally eliminate opportunistic creation of NBC.\n  All newly created NBC should have an initially high entrance barrier, such as a large deposit, and it should be locked down in months even years, so that it forces creators of new NBC would not be short term players.\n  All NBCs are some form of community or organizational governance instrument, so that its use and its performance data in real time is of great value. It should be protected and would follow the same kind of public disclosure and participants' identities would be protected using a set of security measures offered by the Newton Infrastructure.\n  Because all NBCs must be kept for as long as Newton Infrastructure exists. Therefore, a maintenance fee for its data and bandwidth consumption must be collected to support the infrastructure. This amount of fee needs to be dynamically adjusted based on the ongoing pricing of computation and communication costs at the time.\n  Rationale (optional) #  Allowing non-technical people to create NBC is the mission. However, there are much more governance techniques required to manage and orchestrate the communities that uses NBC. Currency issuance is clearly going to be a new dimension that organizations that adopts NBC must learn from the overall Newton Community. Therefore, a think tank organization that specializes in currency mechanism design must be initiated to develop material that shows NBC creators and participants to better practice their use of NBC. Currency is designed to be liquidable assets, so that it is a double edged swords. It must be used with tremendous care.\nTest Cases (optional) #  Newton Community itself should be the first one to practice the use of NBC. The currency should be the Newton currency as it is being used on the Internet.\nBefore we deploy the first NBC, certain kind of social dynamics and organizational infrastructure must be prepared. For example, one should use TLA+ and NetLogo to assess the symbolic dynamics and agent-based system dynamics of a group of participating agents. Then, a procedure will be deployed and submitted to the following Safety and Liveness tests. After certain iteration, we will deploy the actual NBC to Newton Community.\n Safety tests: After a meaningful NBC creation procedure is defined, a relatively small amount of Newton should be issued as a test case for NBC creation. Then, the community that develops NEPs and other mechanisms for Newton Community evolution should be organized through this NBC. Liveness tests: The cases where the first NBC is being used and how it affects the community could be the liveness case study.  Implementation #  Ideally, all Newton Community\u0026rsquo;s incentive and organizational structures should be managed through the governance procedures of NBC.\nSecurity Considerations #  To ensure security, creation of NBC must go through certain stress test and system test phases. The proposition here is that the first three years, all NBC creation should be submitted through both technical and branding committee, so that decisions for creating currencies would not contradict, or competing with each other for obvious reasons. Overtime, the competing interests should be encoded into some kind of Byzantine Fault Tolerance Mechanism.\nReferences #   Leslie Lamport, Time, Clocks, and the Ordering of Events in a Distributed System, Communications of the ACM, July, 1978.  Copyright #  Copyright and related rights waived via CC BY-SA 4.0.\n"});index.add({'id':6,'href':'/neps-preview/reviews/nep-review-0001.html','title':"NEP Board Review 0001",'content':"Results #     NEP No. Type Accepts Denies Rejects Final Result     NEP-6 new Draft 6 0 0 Accept   NEP-7 new Draft 6 0 0 Accept   NEP-10 new Draft 6 0 0 Accept   NEP-12 new Draft 5 0 0 Accept    Details #     Role Github ID NEW ADDR. NEP-6 NEP-7 NEP-10 NEP-12     NEP Editor  @arisac NEW182LTNoiufc9tiveZdno3HXH5yEmUURKUiac   new Draft View on NewExplorer new Draft View on NewExplorer   NEP Editor  @liuyong5653 NEW182VbmZs3TyC268wz7Kq4Cznssv7WzRPDq7j new Draft View on NewExplorer      NEP Editor  @weixuefeng NEW182PdJBJoMnGAub6KJ6YrhSPHWrFE9RSBmGE  new Draft View on NewExplorer     NEP Board Member  @benkoo NEW182XacauX8woduncHaXTzNGCFnk7B15z34hi       NEP Board Member  @evanliuchina NEW182Jqu3ok6ZnjkLAyhpSw9WEJXhEwUYX4jLR Accept View on NewExplorer Accept View on NewExplorer Accept View on NewExplorer Accept View on NewExplorer   NEP Board Member  @i29 NEW182TpZToiXBk1SkR1bMJLUxguPxFsZciz123 Accept View on NewExplorer Accept View on NewExplorer Accept View on NewExplorer Accept View on NewExplorer   NEP Board Member  @jiangtao-tang NEW182XmN8jkgnkW8rtu9jRriQJjnEBXSbZZuHJ Accept View on NewExplorer Accept View on NewExplorer Accept View on NewExplorer Accept View on NewExplorer   NEP Board Member  @leewillson NEW182ZheiEbSBW3SbtETmXEgdG5X9GvFuLRun2 Accept View on NewExplorer Accept View on NewExplorer Accept View on NewExplorer Accept View on NewExplorer   NEP Board Member  @VieYang NEW182bMUiAM1nXMjcwri8zNrgZftcnPJc1uVie Accept View on NewExplorer Accept View on NewExplorer Accept View on NewExplorer Accept View on NewExplorer   NEP Board Member  @xiawu NEW182Kt8siZGciPGBss3rg7GmJqfZ7CUafVUHH       NEP Board Member  @xujizhe unregistered       NEP Board Member  @zqy15789 NEW182EFjxZjxRJcfBdJBHEuMTYNsK7RLTFeiiJ Accept View on NewExplorer Accept View on NewExplorer Accept View on NewExplorer     Notice #  Voting Period: 2020-05-08 12:00 UTC+8 to 2020-05-09 12:00 UTC+8\nNEPs to review: NEP-6, NEP-7, NEP-10, NEP-12\n Voting Address: NEW182N1aGYZAHMZAFAuaahwSDVrMXJsmypNEPS NEPs Github repository: link NEPs Gitter Chatroom: link NEPs Voting Demo Video: English ver link  NEP-6 #   NEP-6: Basic Token Standard (NRC-6) Type: new Draft NEP Editor: @ liuyong5653 Review URL: https://github.com/newtonproject/NEPs/blob/c5f360f6b97284169272000de1746d94c5a8413d/NEPS/nep-6.md Voting Decisions: accept / deny / reject Voting Note: decision new NEP-6 Draft 0@14599984  NEP-7 #   NEP-7: Non-Fungible Token Standard (NRC-7) Type: new Draft NEP Editor: @ weixuefeng Review URL: https://github.com/newtonproject/NEPs/blob/35dd524fec74ac35e0f2f864f9a45ec85956188b/NEPS/nep-7.md Voting Decisions: accept / deny / reject Voting Note: decision new NEP-7 Draft 0@14599885  NEP-10 #   NEP-10: Invoice-Token-Standard (NRC-10) Type: new Draft NEP Editor: @ arisac Review URL: https://github.com/newtonproject/NEPs/blob/884ce96408b1238875c50d1e3290ad4c15b6f768/NEPS/nep-10.md Voting Decisions: accept / deny / reject Voting Note: decision new NEP-10 Draft 0@14600736  NEP-12 #   NEP-12: NewORG Standard (NRC-12) Type: new Draft NEP Editor: @ arisac Review URL: https://github.com/newtonproject/NEPs/blob/be245afa36c23189fe4b03243f4f19713eb52319/NEPS/nep-12.md Voting Decisions: accept / deny / reject Voting Note: decision new NEP-12 Draft 0@14600811  "});index.add({'id':7,'href':'/neps-preview/reviews/nep-review-0002.html','title':"NEP Board Review 0002",'content':"Results #     NEP No. Type Accepts Denies Rejects Final Result     NEP-19 new Draft 5 0 0 Accept    Details #     Role Github ID NEW ADDR. NEP-19     NEP Editor  @arisac NEW182LTNoiufc9tiveZdno3HXH5yEmUURKUiac new Draft NewExplorer   NEP Board Member  @benkoo NEW182XacauX8woduncHaXTzNGCFnk7B15z34hi    NEP Board Member  @evanliuchina NEW182Jqu3ok6ZnjkLAyhpSw9WEJXhEwUYX4jLR    NEP Board Member  @i29 NEW182TpZToiXBk1SkR1bMJLUxguPxFsZciz123 Accept NewExplorer   NEP Board Member  @jiangtao-tang NEW182XmN8jkgnkW8rtu9jRriQJjnEBXSbZZuHJ Accept NewExplorer   NEP Board Member  @leewillson NEW182ZheiEbSBW3SbtETmXEgdG5X9GvFuLRun2 Accept NewExplorer   NEP Board Member  @VieYang NEW182bMUiAM1nXMjcwri8zNrgZftcnPJc1uVie Accept NewExplorer   NEP Board Member  @xiawu NEW182Kt8siZGciPGBss3rg7GmJqfZ7CUafVUHH    NEP Board Member  @xujizhe unregistered    NEP Board Member  @zqy15789 NEW182EFjxZjxRJcfBdJBHEuMTYNsK7RLTFeiiJ Accept NewExplorer    Notice #  Voting Period: 2020-06-04 12:00 UTC+8 to 2020-06-05 13:00 UTC+8\nNEPs to review: NEP-19\n Voting Address: NEW182N1aGYZAHMZAFAuaahwSDVrMXJsmypNEPS NEPs Github repository: link NEPs Gitter Chatroom: link NEPs Voting Demo Video: English ver link  NEP-19 #   NEP-19: Physical Commodity Standard (NRC-19) Type: new Draft NEP Editor: @ arisac Review URL: https://github.com/newtonproject/NEPs/blob/96918c156537be45d05dbdb3cd74baa551c0bd78/NEPS/nep-19.md Voting Decisions: accept / deny / reject Voting Note: decision new NEP-19 Draft 0@153788199/NEPS/nep-12.md Voting Decisions: accept / deny / reject Voting Note: decision new NEP-12 Draft 0@14600811  "});index.add({'id':8,'href':'/neps-preview/reviews/nep-review-0003.html','title':"NEP Board Review 0003",'content':"Results #     NEP No. Type Start/End Block Accepts Denies Rejects Result     NEP-12 update Draft 15756530/15876529 7 0 0 Accept   NEP-20 new Draft 15756497/15876496 7 0 0 Accept   NEP-21 new Draft 15756503/15876502 7 0 0 Accept   NEP-22 new Draft 15756508/15876507 7 0 0 Accept   NEP-23 new Draft 15756516/15876515 7 0 0 Accept   NEP-24 new Draft 15756523/15876522 7 0 0 Accept    Details #     Role Github ID NEW ADDR. NEP-12 NEP-20 NEP-21 NEP-22 NEP-23 NEP-24     NEP Editor  @arisac NEW182LTNoiufc9tiveZdno3HXH5yEmUURKUiac update Draft NewExplorer new Draft NewExplorer new Draft NewExplorer new Draft NewExplorer new Draft NewExplorer new Draft NewExplorer   NEP Board Member  @benkoo NEW182XacauX8woduncHaXTzNGCFnk7B15z34hi Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer   NEP Board Member  @evanliuchina NEW182Jqu3ok6ZnjkLAyhpSw9WEJXhEwUYX4jLR Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer   NEP Board Member  @i29 NEW182TpZToiXBk1SkR1bMJLUxguPxFsZciz123 Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer   NEP Board Member  @jiangtao-tang NEW182XmN8jkgnkW8rtu9jRriQJjnEBXSbZZuHJ Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer   NEP Board Member  @leewillson NEW182ZheiEbSBW3SbtETmXEgdG5X9GvFuLRun2 Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer   NEP Board Member  @VieYang NEW182bMUiAM1nXMjcwri8zNrgZftcnPJc1uVie Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer   NEP Board Member  @xiawu NEW182Kt8siZGciPGBss3rg7GmJqfZ7CUafVUHH         NEP Board Member  @xujizhe unregistered         NEP Board Member  @zqy15789 NEW182EFjxZjxRJcfBdJBHEuMTYNsK7RLTFeiiJ Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer Accept NewExplorer    Notice #  NEPs to review: NEP-20, NEP-21, NEP-22, NEP-23, NEP-24, NEP-12\n  NEP Editors  NEP Board Members NEPs Github repository: link NEPs Gitter Chatroom: link NEPs Voting Addr.: NEW182N1aGYZAHMZAFAuaahwSDVrMXJsmypNEPS NEPs Voting Demo Video: English ver link  NEP-20 #   NEP 20: Newton Encoded Asset Transaction (NEAT) Type: new Draft NEP Editor: @arisac Review URL: https://github.com/newtonproject/NEPs/blob/e6d8fd5b421dac7d6bac795320ff1a4fa6e75608/NEPS/nep-20.md Voting Decisions: accept / deny / reject Voting Note: decision new NEP-20 Draft 0@15756496  NEP-21 #   NEP 21: Newton Physical Asset (NPA) Type: new Draft NEP Editor: @arisac Review URL: https://github.com/newtonproject/NEPs/blob/e6d8fd5b421dac7d6bac795320ff1a4fa6e75608/NEPS/nep-21.md Voting Decisions: accept / deny / reject Voting Note: decision new NEP-21 Draft 0@15756502  NEP-22 #   NEP 22: Newton Composite Asset (NCA) Type: new Draft NEP Editor: @arisac Review URL: https://github.com/newtonproject/NEPs/blob/e6d8fd5b421dac7d6bac795320ff1a4fa6e75608/NEPS/nep-22.md Voting Decisions: accept / deny / reject Voting Note: decision NEP-22 Draft 0@15756507  NEP-23 #   NEP 23: NEAT Backed Currency (NBC) Type: new Draft NEP Editor: @arisac Review URL: https://github.com/newtonproject/NEPs/blob/e6d8fd5b421dac7d6bac795320ff1a4fa6e75608/NEPS/nep-23.md Voting Decisions: accept / deny / reject Voting Note: decision new NEP-23 Draft 0@15756515  NEP-24 #   NEP 24: Newton Pre-paid Card (NPC) Type: new Draft NEP Editor: @arisac Review URL: https://github.com/newtonproject/NEPs/blob/e6d8fd5b421dac7d6bac795320ff1a4fa6e75608/NEPS/nep-24.md Voting Decisions: accept / deny / reject Voting Note: decision new NEP-24 Draft 0@15756522  NEP-12 #   NEP 12: NewORG Standard (NRC-12) Type: update Draft NEP Editor: @arisac Review URL: https://github.com/newtonproject/NEPs/blob/3cf6f9b720b2ea52eeea3d95eb0d44e19a8f8fa1/NEPS/nep-12.md Voting Decisions: accept / deny / reject Voting Note: decision update NEP-12 Draft 0@15756529  "});index.add({'id':9,'href':'/neps-preview/neps/nep-0000.html','title':"NEP Genesis",'content':"Summary: #  For the sake of the open, transparent governance, we propose compiling all suggestions related to the Newton Project using the Newton Evolution Proposal (NEP) template for unified numbering and management. The proposals are then put to the community for broader discussion, getting opinions and suggestions from all parties involved before forming final conclusions.\nDetails: #   Anyone can submit an NEP. The Newton Foundation is responsible for assigning an exclusive number to each. All subsequent NEPs must use this format as a template. The status may be “draft in discussion,” “not accepted,” “awaiting implementation,” “implemented,” or “implementation delayed.” The category may be “economic model,” “personnel,” “technical,” “community governance,” or “business.” After submission of the NEP, it is sent to the community for broader discussion, getting opinions and suggestions from all parties before a final decision is made. The “draft in discussion” stage lasts 30 calendar days. If no decision is reached during that stage, the status is changed to “not accepted.”  "});index.add({'id':10,'href':'/neps-preview/neps.html','title':"Neps",'content':""});index.add({'id':11,'href':'/neps-preview/neps/nep-0012.html','title':"NewORG Standard (NRC-12)",'content':"Simple Summary #  NewOrg template standard represents the living organization in newton ecosystem and a new DAO paradigm for the next generation social governance and collaboration.\nAbstract #  NewOrg methods and standard based on NewChain and smart contract technologies are defined as is:\n based on NewChain and its smart contract technologies. to replace the traditional limited corporation with new governance paradigm based on blockchain technologies. to define a set of meta rules for organization governance, and clarify the separation of these rules between NewChain layer and contract layer to implement: (1) business irrelative meta rules; (2) flexibility of neworg governance token; (3) anchoring all neworg to NewChain. compatible with staking nodes as well as NewForce incentivization model in current NewPay for easier migration. a complete open standard for any organization, institution, goverments to create NewOrg and transfer the centralized trust to the decentralized infrastructure and trust.  Motivation #  To replace the traditional limited corporation with new governance paradigm based on blockchain technologies, illustrated as below:\nSpecification #  Meta Data #  The meta data functions are constant methods that returns information. Parameters all have a leading _.\norgInfo #  returns the informaiton of the Org:\n _name, the name of the Org _type, the type of the Org  1 - Commercial Instituation 2 - Community Group 3 - Government Sector 4 - Non-profit Organization 5 - Developer Community   _description _countryRegion _url, the website of the Org _managementFee, %, ranging 0-100, of mining profits that would be attributed to the Org owner  function orgInfo() public view returns (string _name, uint8 _type, string _description, string _contryRegion, string _url, uint8 _managementFee) totalStaking #  returns the total staking amount of NEW (unit: ISSAC) of the Org.\nfunction totalStaking() public view returns (uint256 _amount) stakingAmountOf #  returns the staking amount of a specific address which is a partner of the Org.\nfunction stakingAmountOf(address _partner) public view returns (uint256 _amount) versionTag #  returns the versionTag (e.g. \u0026ldquo;0.1.0\u0026rdquo;) of the Org.\nfunction versionTag() public view returns (string _versionTag) owner #  returns the owner address of the Org.\nfunction owner() public view returns (address _owner) countOfMember #  returns the count of members of the Org.\nfunction countOfMember() public view returns (uint256 _count) isMember #  returns if the given address is the member of the Org.\nfunction isMember(address _person) returns (bool _isMember) Interaction / Functions #  The interaction functions are methods that would change the states.\nmodifyOrgInfo #  modifies the information of the Org (refer to orgInfo() above).\nfunction modifyOrgInfo(string _name, uint8 _type, string _description, string _contryRegion, string _url, uint8 _managementFee) increaseStaking #  increases the total staking amount for the caller itself.\nfunction increaseStaking() payable increaseStakingFor #  increases the staking amount for someone else.\nfunciton increaseStakingFor(address _stakeholder) payable decreaseStaking #  decreases the staking amount of the caller.\nfunction decreaseStaking() joinOrg #  joins the Org (as the caller).\nfunction joinOrg() exitOrg #  exits the Org (as the caller).\nfunction exitOrg() Rationale #  Asset Token Matrix #  Possible asset tokens could be formulated with the following Boston matrix:\nTest Cases #  TBD\nImplementation #  TBD\nTBD #  Org token is removed from the original version and it should be considered later.\nReferences #   ERC-20 https://eips.ethereum.org/EIPS/eip-20  Copyright #  Copyright and related rights waived via CC0.\n"});index.add({'id':12,'href':'/neps-preview/neps/nep-0022.html','title':"Newton Composite Asset (NCA)",'content':"Simple Summary #  Newton Composite Asset (NCA) is the base pattern of asset combination that defines the boundary of how two or more than two assets are combined as a single instance. NCA distinguishes from the other types of asset by involving more than one NEAT. Every NCA is defined based on the principle of Behavioral Equivalence1, so that unique properties of NCA can be distinguished computationally and therefore maximize the possibility of code reuse and automated asset valuation.\nNCA creates value through patterns of asset composition. By definition of composition, every NCA is a combination of two or more than two NEATs. The required engineering of how combined NEATs can generate more value than their independent existence, a package that is more than the sum of its parts, is a major source for its value creation. Economically speaking, if components of an NCA can be bought or sold separately as independent NEATs, there would be little necessity to bundle them together as an NCA. Therefore, it is the compositional pattern that defines the unique value of the system as a collective makes an NCA more valuable than the sum of its parts. Effectively, NCA is the programmable device to define NEAT Portfolios. From a practical standpoint, NCA is where value can be created via combinatorial possibilities, when validated by marketplace, is a true form of productivity. In general, all NCA are uniquely prescribed by the content of its portfolio. When the portfolio contains any one item that is non-fungible, the portfolio are considered to be a Non-Fungible NCA. If the NCA are composed of assets that are all replaceable, then, the NCA is considered to be Fungible NCA. Furthermore, when NCA can be broken up to divisible portions, they are considered to be Divisible NCA. When they must be sold in complete packages, they are considered to be Non-Divisible.\nAbstract #  Newton Composite Asset (NCA) is an asset class that defines value through a composition of more than one NEAT components. NCA is the generic data type to define \u0026ldquo;smart contracts\u0026rdquo; in Newton Infrastructure, where economical vehicles can be created out of other existing NEAT-based components. It is equivalent to a program composed of many transactional functions that already existed in the trust-worthy platform.\nMotivation #  In contrast to individual NEAT, NCA is composed of multiple NEATs, whose validation and execution of composed transactions must take extra efforts and maintain. Therefore, the value of an NCA should be greater than the sum of its parts. This is also considered to be the way Newton Community can create new value by defining various ways to combine existing sub-classes of NEATs to create new asset classes combinatorially. This is the place where new value can be generated by having creative minded agents and agencies to select meaningful composition of assets, and perform analysis of their combined values. Then, it is up to the creator of the NCA to programmatically define the price and conditions of transaction of all available NEATs across the Newton Community. This allows any agents or agencies in the Newton Community members to contribute their creativity in terms of how to combine NEATs into NCAs.\nIt is well-known that assets have different values in different spatial and temporal contexts. In most well-known marketplaces, goods and services are often sold when needs arise. The realization of value is often passive. For example, the price of umbrella is often more valuable during rainy days, medical equipments can become particularly valuable when certain diseases become a major threat. These contextual valuation is often realized passively, when event arises. However, such pricing approach not only could cause unreasonable price gauging, in most cases, the supply of goods and services could often be incompatible with the actual needs. Since many of these time-based needs can be overlooked in \u0026ldquo;normal days\u0026rdquo;. NCA provides a vehicle to combine resources in a time-bound transaction. Therefore, many of these time-based transactions can be planned ahead of time. So that foreseeable needs can be planned ahead of time in the process of designing NCA. In theory, when needs are anticipated before needs arises, the pricing of needed goods and services would naturally consider the issue of supply chain capability. Therefore, there would be relevant efforts to fulfill the needs as anticipated. In practice, when certain needs repeatedly occur, new classes of NCA would be created as the community learns about the needs in reality. Therefore, the overall community would become more capable in reaching reasonable supply and demand dynamics.\nAsset Valuation Techniques #  Analyzing the values of NCA requires a new breed of simulation tools. Since the market value of asset is bounded to a societal context, and the future of this realistic context always have certain uncertainty. The best possible approach is to provide a common Asset Valuation Simulation platform, so that the value of any NCA will be priced based on the simulation, with participant\u0026rsquo;s private investments or insurance policies.\nUser Experience Design of NCA #  NCA\u0026rsquo;s user interface should have a common base-design. Since all NCA are made of other instances of NEAT-based assets, a common navigation interface must be provided for all NCA. So that user would have a consistent experience in identifying and comparing NCAs.\nImmutability and irrefutability #  Every NCA is a unique combination of NEAT assets. So that once it is created, the compositional content cannot be changed.\nNCA\u0026rsquo;s names in NEAT Namespace #  NCA can be represented as a registered name in NEAT\u0026rsquo;s namespace. It should be a subclass of NEAT, having its sub-Namespace code segment. This unification of NCA in NEAT will significantly reduce the complexity of NCA management.\nSpecification #  As mentioned in NEAT, the foundational building blocks of NCA is NEAT. The composition of NEAT into NCA is based on pi-Calculus. Every NCA is defined as follows:\nSyntax and Semantics #  NCA is a composite data structure defined by NEATs or other instances of NCA. As shown above, NCA can be defined recursively. The legitimacy of NCA is defined by the temporal and logical prescription of each NEAT, for example, if certain assets requires the concurrent availability of other collateral assets, such as meat delivery must be accompanied by refrigeration service, then, relevant temporal logic conditions must be satisfied. By embedding logical and temporal conditions within each NCA, the NCA composition is the executable logic that defines whether certain contract is considered fulfilled or breached. NCA can be composed of any number of existing NEATs. For example, it can be a combination of existing NPA (Physical Assets), NBC (Newton-backed Currencies), and NPC (Newton Prepaid-Card). By specifying the asset components of an NCA, it also automatically check the temporal and logical validity of these composited asset, so that all transactions are automatically verified statitically, and dynamically, based on a common data type, NEAT.\nA unique feature of NCA is the creator. Since every NCA spells out a unique composition of asset content, its creator is like an artist/author, that creates a unique portfolio of assets. Therefore, the account, or accounts that create such composition, should be associated with this value creation process, and should be responsible for the rewards and possible damages of this value composition.\nMeta Data #     Item Description Behaviors/Properties     Creation Input     Creator Accounts The Newton Account identities that creates the said NCA deploy/can not be changed   Associated NEATs A list of NEAT involved with this NCA at least one NEAT   Portfolio Rules A composition that describes the quantity and sequence of NEAT/NCA rule should be described in pi-Calculus   Status The status of NCA is can be separated into following kinds: Proposed, Tested, Verified, Executed, Decommissioned a finite set of status classes   ** Evolution History **     Developmental History A list of time points when NCA is created and modified new timestamps are added as changes made   Execution History A list of NCA execution time points, including reference to executed NCAs immutable data records    Rationale #  NCA is a way to leverage compositional efforts to create value. Such compositional value creation can be best illustrated by Bitcoin as a currency. Since Bitcoin as a system creates market value through a composition of three communities, they are:\n A community of Miners: a large number of administratively independent machines, that agrees on a common transaction ledger. A community of Traders: a large number of accounts and agents who are transferring funds between different accounts. A community of Coders: an open sourced community that keeps improving and fixing source code the offers better and more secure software functionalities.  The value of NCA comes from its composition of complementary functions. Separately, each community has relatively limited value constrained by their physical surroundings. Once combined through Bitcoin, or some form of NCA, the credibility of assets and ubiquity of asset liquidity becomes pervasive. Effectively, this three way composition of Miner, Traders, and Coder accounts, brings together a living entity that is distributed across the globe, and works around the clock, unstoppably. Similarly, there will be many forms of assets that can be composed to broaden its value across space and time. The role of NCA as a root class of other NCAs, is to provide a template the covers how asset valuation can be done, how to design user interfaces for other NCAs, and demonstrate the immutable and irrefutable values of assets. Last but not least, the value in Namespace, is the foundation of asset management, and how NCA plays in the Namespace must abide to a set of non-negotiable rules.\nHigh Level Architecture #  NCA is essentially a composed NEAT contract that needs the widest possible reachability to the marketplace. For NCA to exists, it must first be created. The creation process should follow the typical DevOps/CI/CD type development cycle. The DevOps/CICD workflow is often associated with the idea of Event Sourcing, short handed as ES. For trivial combination of NEATs, simple user interface that allows users to combine NEATs into portfolio of NEATs would be a starting point. Once any NCA is created with existing NEATs, a sequence of testing and validation procedure must be applied, so that programmatically detectable conflicts can be first conducted before the created NCA is released to the marketplace.\nIt can be thought of as a typical exchange matching engine, when the ask/bid combinations are matched, the transaction would take place. In short, it can be simply considered as a marketplace of NCAs, and they can be bought and sold as if they are listed entries of stock or futures in current market practice. Knowing the transactional nature of NCA, the design of NCA exchange marketplace can be implemented using the existing exchange engine that is commonly designed to execute stock or virtual currency trades. As mentioned earlier, the buyer/seller matching algorithm should be based on some automated algorithms. These algorithms should following the Behavioral Equivalence1properties. One way to defining such property is to classify NCAs that are ready to be exchanged in terms of Behavioral Equivalences. So that all transactions can automatically take place based on the pre-processed classification.\nA rather complete architectural diagram based on CQRS-architectural pattern could be referenced to implement the overall system. The diagram was originally created to explain the CQRS-Event Sourcing concept by Daniel Whittaker. Implementation #  There are two aspects of NCA implementation. The first one is NCA creation by combining NEATs. The second one is to release NCAs into a public marketplace to be traded. The first one should be an exercise of user interface design and automated testing. As mentioned in the High Level Architecture, the automated testing should follow priniciples prescribed by [1] Behaviral Equivalence of said NCAs. The testing can be conducted using formal model checking tools such as TLA+ or to be implemented in Coq.\nThe second one is a matching engine that allows traders to quickly search for their desirable NCAs and allow buyers and sellers to easily find their targets. The implementation of matching and transactional engine can be implemented using Event Sourcing and CQRS-based implementation models. For the choice of software stack, Apache-Kafka is a high performance platform that can execute up to millions of transactions per second.\nReferences #   Rocco De Nicola, Behavioral Equivalences, [ Research Gate], [ L-Università ta' Malta]   Alex Pentland, Alexander Lipton, and Thomas Hardjono, Building the New Economy, [MIT Press]  Copyright #  Copyright and related rights waived via CC BY-SA 4.0.\n"});index.add({'id':13,'href':'/neps-preview/neps/nep-0020.html','title':"Newton Encoded Asset Transaction (NEAT)",'content':"Simple Summary #  Newton Encoded Asset Transaction(NEAT) defines the root data type for all asset exchanges. Once a new record of NEAT is registered into Newchain, it represents a form of irrefutable accountability based on the immutable features of Newchain. To help transaction assess the worthiness of transactions before their commitment, all transactions have a common field, called: Bounded Accountability, which defines all known exit conditions when a transactional process is breached. From an economic viewpoint, the security of every transaction must be insured by worthwhile collateral assets, which include the reputation history of the exchange participants. To make transactions trust-worthy, all transactions must be encoded as an executable algorithm, and all human initiated asset exchange execution are authorized by cryptographically ensured procedures. NEAT delivers Bounded Accountability of transactions by representing transactions based on\n trust-worthy timestamps, irrefutable asset identities, non-repudiable agreement actions, deposited collaterals.  NEAT can be seen as a Domain Specific Language (DSL) that is dedicated to represent transactional accountability. The domain represented by DSL is the domain of transactions, since all subsequent transactions are reprented by the root data class, NEAT. More importantly, only NEAT and its subclasses will be recorded on Newchain, which will become durable and accountable in the history of NEAT execution. As a DSL, NEAT provides a small, yet expressive vocabulary of asset types, so that practical business transactions can be composed of NEAT to represent a broad range of economic activities with computable risk profiles with a common field: Bounded Acountability. NEAT presents a small set of asset types as its linguistic primitives. For instance, NewID/NewKYC accounts, NEP-21: Newton Physical Asset, NEP-22: Newton Composite Asset. It is based on these primitives, applications such as NEP-23: NEAT-backed Currency, NEP-24: Newton Prepaid-Card can be defined for practical use. The notion of Buy, Sell, Borrow, and Bid, are the actions or verb primitives of NEAT. The runtime execution of NEAT is carried out by NewKernel, and all transactional records will be immutably stored on Newchain. The following diagram outlines the architecture of the NEAT execution environment.\nAbstract #  Newton Encoded Asset Transaction (NEAT) is a Domain Specific Language (DSL) that represents asset transactions with computable Bounded Accoutability. The goal of NEAT is to provide a rigorous language to construct asset portfoilios on an exchange platform to facilitate asset-sharing practice. NEAT facilitates sharing by always make both providers and receivers of the asset accountable of their actions in terms of bounded collaterals. Every NEAT-based transaction must have computable and verifiable data items that represent the accountability of the transaction participants. In other words, all participants must earn their reputation over time, or they must deposit a reasonable amount of asset to insure their own transactional actions. With Newton\u0026rsquo;s immutable ledger and accounts represented by NewID, accounts with good credit history will be able to carry more trust-worthiness and will be given more freedom in practicing wider ranges of commercial activities. To instill accountability to every NEAT-based transactions, every transaction is associated with the following security features:\n every transaction should be guaranteed by a set of collateral asset, deposited by participants of the transactions or the transaction platform. all transactions must be tagged with secure timestamping services, public keys for participating accounts (NewID and NewID-based NewKYC), globally defined asset identities (IPv6, MAC Address, and other IoT and asset-specific tags) composable semantics of delivery/reception mechanisms based on pi-calculus. Univalence: All NEAT utilizes a unifying security model, the degree of security should be measured by equivalent units, measured in Newton. Newton as a currency is bound to physical time.  NEAT as a DSL for Transactional Operations #  From the highest abstraction level, all transactions are composed of three main types of operations, Selling, Buying and Matching of Buyer/Sellers. These three operations are to be recorded into an immutable transactional datastore, as shown in the following diagram:\nThe most common states are listed in the following table:\n   Function Description Permission     Ready for More Transactions Allow additional transactions to be processed on NEAT. System Level   Initiate Transaction Allow NewID accounts to intiate new Transactions NewID Accounts   Seller Ops Create a new offerings to be bought, including credit and offering validations NewID Accounts   Buyer Ops Create a new bid to obtain products or services NewID Accounts   Matching Ops Match Buyer(s) and Seller(s) based on NEAT Contract System Level   Transaction Completion After all commitments are checked, automatically store transaction records on Newchain System Level   Failed Transaction Conditions Terminate Transaction based on contractual conditions. System Level   Bounded Accountability Every NEAT and its subclasses will be associated with one entry of Bounded Accountability System Level (Editable Once by the NewID account of Initiate Transaction)    Technically speaking, NEAT is a domain-specific language with a immutable transaction ledger and a unifying real-world clock. It can be expanded to encode other types of transactions that follows this generic pattern. The main objectives of creating NEAT is about creating a unifying namespace to , so that knowledge derived from operating this transactional ledger can be uniformly shared to improve the soundness and precision of transaction accountability. NEAT as an abstract specification of a DSL in the Domain of Bounded Accountability is not limited to a specific stack of software/hardware technologies. However, NEAT\u0026rsquo;s initial reference implementation will be bound to the archietctual patterns of Serverless Applications, Function as a Service (FaaS), Event Sourcing, Command Query Resposibility Segregation (CQRS), and the process patterns, DevOps, GitOps, and MLOps. These architectural guidelines will limit the technical discussion, and engineering implementation to a specific level of data abstraction, particularly bounded to time-oriented namespace management. This temporally-oriented design principle will permeate the overall engineering efforts, including the design and implementation of human-data interaction interfaces.\nMotivation #  NEAT is about providing a unifying, and formally verifiable data type that represents asset transaction activities on Newchain. The motivation to unify transactional data on one formally verifiable data type is to avoid human intervention without valuable collaterals and maximize knowledge reuse with respect to transaction processing. This data type would allow anyone with a Newchain account to participate in a transparent and unbiased asset transaction service, purely defined by executable logical contracts. The accountability of transactional activities is grounded in Newchain, whose infrastructure provides trust-worthy facts through irrefutable account-based actions and immutable event occurrence sequence. To maximize knowledg reuse, NEAT is defined as the root class for all other types of transaction. Having one unifying base class, provides a discipline to organize and compare the differences between all transaction processing strategies. This unity will significantly reduce the complexity of system development and maintenance, therefore minimize the transaction processing cost (cost of middleman).\nTime-bound ACID Transactions #  A key feature of NEAT is the notion of Bounded Accountability. The security of accountability is to ensure by data security, often prescribed as the ACID properties of transaction, Atomicity, Consistency, Isolation, and Durability. The \u0026ldquo;economic value\u0026rdquo; or transactional accountability is bounded by the \u0026ldquo;correctness\u0026rdquo; of contract execution during runtime. Therefore the correctness is also bounded by a time window, from the time point of contract initiation, up to the point of contract fulfillment or failure acknowledgement. Knowing that Newchain is an non-stoppable real-time immutable data store infrastructure, participants of NEAT-based transactions can judge the boundaries of accountability based on the physically meaningful timestamps, and ACID properties associated with data transactions. All claims of accountability must be follow the consistency in timestamped records to infer their respective judgemental outcomes. Combining this timestamped data with formal data analysis tools, such as the System Specificatin language: TLA+9. An abstract specification language such as TLA+, can be used to define the possibility space of accountability in temporal dimensions, and allow the possibility state space to be symbolically enumerated and examined by participants prior to commiting to certain transaction. Therefore, either transaction participants conduct extensive verification processes using formally defined logic, or they simply declare the admission of bounded risks, and therefore agree to the said Bounded Accoutability. By explicitly denoting transactions with a computable field: \u0026ldquo;Bounded Accountability\u0026rdquo;, such data field provides a formal structure to express risk profiles of all transactional activities uniformally. All risks that participants are willing to take can be expressed in a set of objectively defined risk assessment statement executable by temporal logic.\nTemporal Logic Reasoning Engine: Behavioral Equivalence #  To make NEAT pratical, yet pertains sufficient robustness from error, the vocabulary of NEAT, will need to be incrementally refined to fit the changing application contexts. The refinement process will be supported by formal method tools, such as TLA+. Tools such as TLA+ will first denote distinguishable transactional states of transaction activities, and then, use these time-based state notation to classify different kinds of asset transaction activities. This is also where the overall system establish equivalence between transactional processes with different names. Then, these classified transactional activities can be assigned context-dependent terms, and these terms will be managed in a globally managed NEAT reserve word dictionary. This global dictionary of NEAT defines equivalent classes of transactional behavior, so that all transactional behavior will be grounded in the namespace of formal analysis, not in the context-dependent namespace. Grounding all transaction models with a formal behavioral representation allows the NEAT system to evolve around abstract specifications. Concrete implementation and operational data will also be referenced in the overall knowledge base, but they will only serve in a supportive role for evolving the NEAT language.\nVocabulary Management in Wiki #  As NEAT gets applied in operational contexts, natural language synonyms of these formally defined vocabulary will be slowly admitted to the dictionary of alias, published in a distributed wiki database. This wiki database provides a common repository for participants to publish and read the definition of different types of transactional activities. The natural language oriented content of Wiki, allows many kinds of people ,allowing non-technical people to better engage with NEAT. The design and evolution of NEAT, will follow the methodology of Domain Deriven Design(DDD), where the domain is grounded in temporal logic. Knowing that time arrow will always increase entropy, the namespace of NEAT will simply be version controlled using uniquely defined time-stamps on Newchain. In other words, the version control mechanism of NEAT\u0026rsquo;s dictionary is grounded in Newchain\u0026rsquo;s timestamp sequence. This grounding uniquely combines namespace management with the trust-worthy time-stamping service provided by Newchain, an entropy-based namespace management strategy can naturally classify increasingly complex transaction types, and therefore define all the namespace of known transaction types under one unified dictionary. Intentially maintain logical consistency through the use of one trust-worthy timestamp service, the namespace evolution governed by the second law of thermodynamics will provide the cornerstone to unify the developmental approaches to transaction processes. This time-bound namespace management strategy will support an future-proof transactional processing infrastructure that maximally avoid redundancy in the development and maintenance of transaction processing services.\nUser Experience Design surrounds Time, Immutability and Irrefutability #  NEAT is designed to support transactional activities between humans. Therfore, the irrefutability of NEAT can be accepted when human participants can consciously agree with transactional actions and records. Participant awareness is built-in a common user experience design framework by following three key human interaction components:\n Actions defined by a time-bound namespace: Users need to know that all transactional actions are distinguished by a unifying timestamp system. The uniqueness of their actions are guaranteed by an irreversible sequence. Record Immutability: Once finished, all transactional records goes into an \u0026ldquo;immutable\u0026rdquo; state, meaning that NEAT records will never be changed after it is committed. Irrefutable accountability: Once participant agrees to do something at certain time point, the irreversibiliy and immutability of this transaction system make the decision maker accountable for their earlier decision. All decision are final at the time points of transaction execution.  In other words, since all other transactions are defined under the umbrella of NEAT, by designing a set of User Interfaces guidelines to ensure human participants are aware of time, immutability, and irrefutability, the transactional system can be accountably deployed to the public.\nSpecification #  Technically, NEAT is designed as a base transactional language with time-bound trust-worthiness. It defines a set of foundational syntax and vocabulary in a structured namespace, specifically organized in Newton Asset Namespace (NAM). NAM provides a unifying framework to named implementations of encryption algorithms, secure timestamp mechanisms, and account security based on Newchain. By using a formalized namespace to manage the identities of the assets being exchanged, and the secured mechanisms of how this asset is being delivered, NEAT provides a unifying exchange protocol for all asset exchange bookkeeping between its community members. NEAT being the root class of asset transaction records, allows other types of assets to be encoded following or extending the possible definitions of asset transaction activities. This data structure is independent of the particular kind of assets that it is being exchanged.\nNEAT Syntax #  NEAT is a base class that can be extened to make up Newton Composite Asset (NCA), that are composed of multiple instances of NEATs. The syntax for defining composed NEAT and its composed structure, NCA, is based on pi-Calculus. pi-Calculus is the formalism of encoding processes and their interactions as a rewrite system. Every NEAT is defined as follows:\nNCA, NEAT := Receive and Send asset a from Transaction Channel C, run NEAT or NCA; Concurrently Execute NEAT and NCA; Create a new Transaction Channle X, run NCA; Repeat multiple instances of NCA; Terminate all NCA transactions; More detail of NEAT syntax will be explained in NEP-22: Newton Composite Asset, because data asset is compositional in nature, and the data content of a NEAT is almost always composed of other data types.\nNEAT Semantics #  The uniqueness of NEAT is defined by a combination of transactional channel C, asset a, time t, and a hashcode of Executing Condition h(E). In practice, all NEAT must have access to collaboral asset CA, and a set of reimbusement rule RR given different conditions during breach of contract. The meaning of the variable names mentioned above are defined here:\n   Variable Name Annotation Explaination     NEAT NEAT_p, NEAT_q represents distinct instance of NEAT named transactions based on the unique combination of C(x,y), a, t (Time), and a Hashcode of Executing Conditions   C(x,y) Account names: (Issuing Account)+ \u0026ldquo;:\u0026rdquo; (Receiving Accounts)+ The direction of asset transfer: x Issuing Accounts -\u0026gt; y Receiver Accounts   a Asset IDs : (Asset ID)* \u0026ldquo;:\u0026rdquo; (Asset ID)* a represents the set of (Asset ID)* to be transferred to from x to y   t Time: (Newchain timestamp)+ A sequence of timepoints of actual transactional events marked by (Newchain timestamp)+   E Executing Conditions: (Deliver Condition)+ \u0026lsquo;:\u0026rsquo; (Reception Condition)+ (Deliver Condition)+ \u0026lsquo;:\u0026rsquo; (Reception Condition)+ are two set of rules that defines the delivery and reception conditions of asset right transfer. Maybe associated with timestamp information shown in (3).   CF Comment Field: (Natural Language content that describes the contract) A field dedicate for human understanding, like the Ricardian Contract. The comments of NEAT can be written in a formatted template, the format could follow Logic Model.   CA Collateral Asset: (Asset ID)+ Collateral asset as a guarantee for participants of this transaction. This is usually defined by the insurance policy for the amount of resources to be issued to participants when transactions failed. (Asset ID)+ should be a set of transferrable assets that will be ditributed in case the transaction fails. Initially, this can be certain amount of Newtons made available to insure the risk coverage of possible transaction failure modes.   RR Reimbursement Rules: (Rule for Reimbursement)+ A contract explicitly defines how to reimburse the participants when the transaction failed to work. The allocation of funds should be independent of the creator of this NEAT type. (Rule for Reimbursement)+: An automated executable contract, written in scripts that would allocate the available cryptographically ensured funds to participants according to various deliver/reception status. The creator of the executable contract should demonstrate that they are NOT in positions of conflict of interest.    Human Interface Design #  Since all subsequent information are subclasses of NEAT data and its organized by a unifying logical clock. It would be necessary to present a unifying user interface to present these temporal data at different scales. The design method can consider the formalism presented by Chris Stolte et al, in their Multiscale Data Cubes approach8(http://graphics.stanford.edu/papers/pan_zoom/paper.pdf).\nExplicit Guarantees #  The value guaranteed by NEAT can be supported by the following explicit guarantees:\n Collateral Assets: all NEAT should have assets dedicated to guarantee the integrity of the transaction. Prior Transaction Records: the historical records of how the identical or similar NEAT was executed with immutable historical data. Mechanized Proofs: The \u0026ldquo;Executing Conditions\u0026rdquo; is the explicit contract that spells out the boundary conditions of how transactions are fulfilled. It should be accompanied by a set of testable conditions, that has an accompanying mechanized proof program to statically check the logical integrity of \u0026ldquo;Executing Conditions\u0026rdquo;. Overtime, the \u0026ldquo;Executing Conditions\u0026rdquo; can be enriched based on operational data to avoid any conflict of interests. Strength of Cryptographic Protection: The system assumes that account actions are initiated by agents who didn\u0026rsquo;t lose their passwords or their cryptographic system are asserted to be in tact. For low risk and low value transactions, cryptographic systems with lower degree of security can be guaranteed by having some form of collabteral assets.  By allowing these three types of explicit guarantees, the value of each NEAT is protected and transaction data recorded on the chain. This also helps to isolate the dependencies between different NEAT, in case some transactions or businesses caused any suspectable results, their problems can be totally independent from other NEAT. The overarching idea is to accommodate all levels of security and asset guarantees based on a lattice-based security classification system. In other words, the levels of guarantee are given a consistent lattice-based namespace to make the risk exposure to be explicit.\nRationale of Bounded Accountability #  The acountability of NEAT transactions are insured by a set of complementary mechanisms, such as security levels characterized in cryptographics, the amount of deposited collaterals, and the algorithmic properties of mechanized proofs. All transactions are assume to only carry risk levels up to the parameterized boundary, therefore, having a set of certified human-machine interfaces, and the relevant computable implementations of Bounded Accountability are essential features of NEAT. When assets are considered to be more valuable than the representable insurance policy, these mechanisms, including human-machine interfaces should prevent assets to be engaged in a NEAT transaction. This protective mechanism works both for the human participants, as well as the NEAT operating infrastructure. On the side of human participants, NEAT exchange should only be initiated after certain security deposit or prior reputation can cover the allowed Bounded Accountability. On the operational side, by parameterizing risk profiles in terms of computable/decidable terms, it becomes possible to automatically assess a large number of transactions in a wide range of application contexts. In other word, the notion of Boundary is determined by the computability of risk parameters. Without presenting risk profiles in terms of computationally representable and effectively computable expressions, it would be impossible to ochestrate the astronomical volume and types of transactional activities that can be automatically conducted using currently existing Internet of Things infrastructure.\nBalancing Security Protection Pragmatically #  The above mentioned guarantee mechanisms together form a mutually dependent protection ecology. A NEAT without the protection of sound cryptographic security system, or it doesn\u0026rsquo;t have an automatically verifiable proof, the participants should not put down too much Collateral Assets to guarantee the specific NEAT transaction. On the other hand, when the maturity of NEAT \u0026ldquo;executable conditions\u0026rdquo; are throughly tested both operationally with historical records, and mechanical proof results, then, it would be much likely that such NEAT is going to deserve larger amount of collateral assets. The key idea is that NEAT is a platform to allow participants to dynamically construct a bounded security using existing infrastructure, without waiting for all four conditions to reach perfection.\nFreedom in Constructing Transactional Contracts #  The transactions of digitally representable assets can be best illustrated by the four fundamental rights as explained by Richard Stallman\u0026rsquo;s \u0026ldquo;Free Software, Free Society\u0026rdquo;[ available here].\n   Free Software pi-Calculus Concept     The right to use Software The choice to engage certain interactive process (Human choose to use certain piece of software)   The right to understand the working mechanisms of Software Parallel execution of the software, including mirror the understanding of the working principles   The right to modify the software for other Uses Change the software in ways that covers the way it didn\u0026rsquo;t work before (Prohibit or enable certain new functions)   The right to re-distribute the modified Software Replicate the software/data asset in alternative distribution channels (Re-distribution for profit)    Leveraging the fundamental rights to the four composable rules, one can define a way to cover a wide range of data asset transaction scenarios that have been investigated for decades by prior luminaries, such as Richard Stallman, Robin Milner, and Leslie Lamport.\nImplementation #  High Level Architecture Design Principles #  NEAT as a generic format of transaction, is the data structure that controls the states for all asset transfer. It is also an extensible programming language with a particular application domain. Its syntax, semantics and pragmatics can be defined using formal language modeling tools, such as the K Framework. Overtime, the system does NOT need be bound to specific tools or speicific implementations. For example, NEAT can be implemented using hand coded C, or automatically generated code modeled on K Framework. NEAT\u0026rsquo;s underlying time-oriented data store, do not necessarily need to be bound to blockchain-based transaction model. Any transaction model that fulfills the notion time-based Bounded Accountability, as specified by the abstract specification will be admitted. This document is intended to be written as an implementation neutral specification, that can be examined in terms of abstract logical arguments, not in terms of the run time performance of engineering artifacts. Therefore, this document is intentionally written as an abstract specification of NEAT, and its implementation should be separated from this specification. At the same time, NEAT is also an operational platform, it needs to leverage existing engineering wisdom and tools that has already demonstrated scalability and technical sophistication. So that the following section will present the guidance in implementing a scalable NEAT infrastructure.\nEvent Sourcing, CQRS, and DDD #  Since NEAT is highly depedent on time, the software implmentation strategy should be aligned with known architectural patterns that provides time-sensitive data structures. For example, to implment concurrent systems, adopting event sourcing10patterns such as CQRS10(Command Query Resposibility Segregation), and define transactions in terms of their business domains using DDD (Domain-driven Design), are high level architectural designs that do not directly involve coding. By separating design from implementation has many long term advantages, and allow implementation decisions to be based on architectural arguments, not based on implementation details.\nThe focus of NEAT is all about secure real-time transactions, that means performance is of utmost critical concern. Using design patterns such as Event Sourcing, it is possible to better investigate broadly applicable design solutions without involving source code level experiments. More importantly, it allows implementers to systematically search for industrial strength solutions that are designed to solve these fundamental, system-level issues, such as security, high performance, irrefutable transaction processing. Even if these technical solutions are solved by our own implementation, it should be organized as a generic tool that can be reused in other projects.\nTo manage data at scale, NEAT will follow an architectural guideline that separates the overall system into two planes, namelythe Control Plane and Data Plane. The purpose of separating data from the controlling mechanism is to embrace the convention in the Cloud Native movement. Separating systems into composable modules made of meshed services. The origin of this idea of Control Plane vs. Data Plane was popularized by Istio\u0026rsquo;s Service Mesh architecture. However, this high level division of responsibilities is a useful guideline. The matching classification to NEAT and Newton\u0026rsquo;s namespace is shown as below.\nContinuous Workflow in evolving NEAT #  Implementing a programming language is about testing hypothesis of adopting various vocabulary in the expanding application contexts. Therefore it is a continuous learning process, and requires certain guidance in keeping pace of such wide open context of learning. A model to keep workflow in check is the well known Khun Cycle, similar to most Continuous Integration and Continuous Delivery/Deployment (CICD/CD) workflow. The term CI/CD is also very much tied to the notion of DevOps, as \u0026ldquo;Development\u0026rdquo; of new code base must be tightly integrated with the way data services are being \u0026ldquo;Operated\u0026rdquo;. The bluring of boundaries between model development and model operation is an inevitable trend as the cycle time of source code evolution is turing at a speed that can only be captured by having the entire development and deployment process run on a fully automated workflow. This fast-evolving idea of code evolution is compatible with the notion of Kuhn Cycle. The key concern in Kuhn Cycle is the idea of acquiring new vocabulary when the system reaches or identifies \u0026ldquo;immcommensurability\u0026rdquo; in its operating experience (problems detected through Data Plane). By applying CICD and being mindful of Kuhn\u0026rsquo;s vocabulary detecting/collecting Cycles, NEAT will become a living engine that is capable of learning and implementing new ideas. In other words, NEAT is designed as a community-based programming language, its own evolutionary cycles should follow a governance model that is similar to the experience of develping new versions of the NEAT language. In other words, NEAT aims to openly invite anyone to participate in the definition of a transaction processing language that is version controlled by a distributed timestamp system. Vocabulary has value, publically accepted vocabulary has measurable value. Ideally, the new NEAT types are new \u0026ldquo;models\u0026rdquo; learned from operational data, sometimes automatically learned through formal method tools or machine learning workflows. In the case of Newchain, since operational data are immutable data, capturing data content with \u0026ldquo;real\u0026rdquo; timestamps. These immutable and publicly revealed data can be the ideal grounding data for MLOps, as the Machine Learning enabled version of DevOps.\nControl Plane (Dev) #  Newton Community\u0026rsquo;s Infrastructure will carry the responsibility of offering the controlling mechanisms of non-repudiability and irrefutability trace. Newton Community demonstrate its service security through the liveness and safety of its \u0026ldquo;service mesh\u0026rdquo;, or the \u0026ldquo;Controlling Mechanism\u0026rdquo; of the operational data. Using this framework, a significant amount of existing code base can be leveraged for use immediately. In the Istio Architecture, the controlling mechanism for security is often called: \u0026ldquo;Citadel\u0026rdquo; component. Using existing code base that already has been tested by industrial strength solutions will drive the total amount of data to be processed through Newton Infrastructure.\nData Plane (Ops) #  The role of NEAT data type is to provide a typing classification scheme for ongoing implementation of specific asset types. Therefore, the focus of NEAT is to become a template, the unifying implementation to ensure the subsequent classes of application specific asset type could enjoy the same level of data security. From an practioner\u0026rsquo;s viewpoint, overtime, NEAT should have a significant number of application specific subtypes, such as the initally planned NEP-23: NEAT-Backed Currency and NEP-24: Newton Pre-paid Card . As the specific sub-types grow in number, more specific applications will have their own tailor-made data types. However, as the sub-type grow in number, the possible errors and potential redundancy will naturally dissipate attention and therefore increase the cost of source code quality maintenance. Therefore, the idea here is to design NEAT as the unifying data type for a programming language. A language specific dedicated to distributed transaction processing engine. Then, the vocabular adopted overtime, could be reused throughout the community, and even over the entire Internet. This way, we can encourage reuse of the high-level architecture. In other words, the Data Plane of NEAT is a dictionary for other implementation. We will design NEAT as a Domain Specific Language that can be customized and extended to other application specific languages. Then, the likelihood of having patterns in NEAT, such as NEAT-backed Currency (NBC) and NPC to be reused could be hidden in the implementation, so that the technical properties can be preserved. It is expected that implementers will add features within their own applications, and by managing the vocabulary as the Data Plane for a service system, we can alleviate some risks in being drawn to serve many design goals. Thereshould be only one unifying set of design goals in NEAT, that is to ensure system correctness, via safety and liveness concerns. Data security represent safety, and Performance features enables liveness possibilities.\nNamespace Management with Formal Methods and Industry Practices #  NEAT as a transaction protocol should define its namespace using Formal Methods and tools. For example, the critical terms, such as Transaction Initial Condition and Ending Conditiion, should be listed as reserved words using tools such as TLA+ to examine their tempoal logic possibilities. The namespace practice should not be only dependent on committee-based voting procedure, but it must include the analysis model of temporal dynamics, and then, use the analysis model as a collateral to support the decision for expanding or reducing the namespace of NEAT. NEAT should adapt open source software tools that has been extensively tested in known industrial applications. For example, for high throughput transactions, NEAT could adopt well-known messaging systems, such as Apache Kafka to implement Byzantine Fault Tolerance through a more flexible and higher bandwidth transaction engine. In certain cases, it is reasonable to identify third party solution providers to implement or offer high performance solutions that satisfies the abstraction functional specifications. For example, Axon Framework as a solution framework could be a starting point to address implementation issues. Regardless of which software framework to be adopted, NEAT will wrap an implementation-neutral Application Programming Interface (API) based on the abstract specifcation, so that NEAT will remain independent from specific implementation detail through API Namespace management. By orchestrating namespace in a unified fashion within NEAT specification, software developers and infrastructure operation providers can offer their services through the notions of FaaS (Function as a Service), Cloud Native Data Services, and Serverless applications, so that NEAT can be completely abstracted away from specific implementation and hardware maintenance.\nSecurity Considerations #  Every NEAT type should be a totally isolated container of its own risks. Every subtype of NEAT will define an equivalent class of risk as measured by our Control Plane. Therefore, the assets associated with the NEAT type should be defined as a bounded liability, so that its risk factors are isolated from the other parts of Newton infrastructure.\nThe Mechanisms of Proofs #  Every sub class of NEAT must go through a rigorous process to demonstrate that risks are divided into explicitly defined namespaces. The techical term is called identifying \u0026ldquo;Behavioral Equivalence\u0026rdquo;. Assets that can be exchanged through the same kind of transactional mechanisms, should use the same \u0026ldquo;class\u0026rdquo; of NEAT contract. The security features of each NEAT contract should be proven through the software development process. Certain anecdotal thinking can be found in Steiner\u0026rsquo;s blog entry5. However, to reach a more rigorous level of security, NEAT should try to prove and approve every new subclass following formal methods as described in Rosu\u0026rsquo;s paper6. Rosu also leads the K Framework development, which is a rewrite-based language design model that can be used to define and verify formal properties of any language. The argument that NEAT must be designed as a proto-language can be traced back to the legend of Tower of Babel, see 7. By having a sound and unifying linguistic root for all transactions, it will significantly broaden the application areas, and more importantly, reduce the risk the risks of misinterpretation, and increase the overall security of the entire transactional system. The working mechanism of proofs are managed in a namespace known as types of NEAT, so that all risk factors can be first reasoned in the categories, or types of risks, before committing to real world applications.\nWhat is a proof in NEAT? #  A proof in NEAT is to show that the contract will do what it claim to do under all possible circumstances.\nIf one only show that all past run time records have all satisfied the contract conditions, the data cannot complete a proof, because future events might break the system. Therefore proof can be done by going through certain automated abstractions. Automatic proof mechanisms have been made available for a while, certain commercial services (Inventor of K Framework, Rosu, created a start up to run mechanized proofs for blockchain contracts.) are also available to help verify \u0026ldquo;smart contract\u0026rdquo; on blockchain infrastructures. The point here is that NEAT should instill an internal mechanism to include certain assets to be allocated for writing and examing proofs. By including an overhead for proving integrity of NEAT contract will instill a new level of security in the design of NEAT system.\nThe dependency or logical sequences of proofs can be displayed as diagrams, also known as proof net. The process of submitting a new NEAT sub class is similar to the workflow of submitting a new piece of source code. The key contribution of Newton Technical Review Board is to provide a secure mechanism to insure irrefutability and provide quality control mechanisms that have been \u0026ldquo;proven\u0026rdquo; over time in the public domain. When uncertain conditions are met, the Newton Review Board will resort to explicit classification, and define a category of risk based on known data. By naming and classifying risks, it will provide significant reuse of intellectual labor to analyze the quality of proposed new NEAT subclasses, and therefore increase the quantity of transactions.\nBackwards Compatibility #  All NEPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The NEP must explain how the author proposes to deal with these incompatibilities. NEP submissions without a sufficient backwards compatibility treatise may be rejected outright.\nTest Cases #  All test cases of NEAT should be classified into two kinds:\n Safety tests: examining conditions for when the contract execution will not cause undesirable situations. Liveness tests: examining conditions for when contract execution will ensure something desirable would actually happen.  The safety and liveness tests should be created based on tools such as Static Analysis and TLA+ and other similar test case generation tools.\nTest cases for NEAT should first be conducted on dedicated Newton Test Chain, so that the compatibility of the system could be managed between the two systems.\nReferences #   Leslie Lamport, Time, Clocks, and the Ordering of Events in a Distributed System, Communications of the ACM, July, 1978.   Richard Stallman, Free Software, Free Society, Free Software Foundation, 2002, PDF  Robin Milner, The Polyadic Pi-Calculus a Tutorial, October, 1991  Chris Newcombe, et al., How Amazon Web Services Uses Formal Methods, Communications of the ACM, April, 2015.   Jutta Steiner. Security is a process: A postmortem on the parity multi-sig library self-destruct, 2017  Grigore Rosu, Formal Design, Implementation and Verification of Blockchain Languages, Paper (University of Illinois), Slides (University of Waterloo), Video (Youtube)   Alex Gendler, How languages evolve, Ted Ed video   Chris Stolte, Diane Tang, Pat Hanrahan, Multiscale Visualization Using Data Cubes, PDF   Leslie Lamport, Specifying Systems: The TLA+ Language and Tools for Hardware and Software Engineering, Addison Wesley  Dominic Betts Julián Domínguez Grigori Melnik Fernando Simonazzi Mani Subramanian   Alex Pentland, Alexander Lipton, and Thomas Hardjono, Building the New Economy, MIT Press   Urbit: A Decentralized Personal Server Platform, Wikipedia  Copyright #  Copyright and related rights waived via CC BY-SA 4.0.\n"});index.add({'id':14,'href':'/neps-preview/neps/nep-0021.html','title':"Newton Physical Asset (NPA)",'content':"NEP 21: Newton Physical Asset (NPA) #     Item Description     NEP 21   Title Newton Physical Asset   Author Ben Koo   Discussions to https://github.com/newtonproject/NEPs/issues/21   Status Draft   Type Standard   Category Technical   Created 2020-05-09   Updated     Simple Summary #  Newton Physical Asset (NPA) is the base class of physical asset classes. NPA requires certain proof mechanisms to be included as a part of guarantee to allow transaction of ownership. Two basic types of proof must be made available:\n Proof of Existence: The asset must provide some mechanism to show the asset exists, such as some online API to show that certain goods or services physically exist, that responded with some provable existence message. Proof of Ownership: This mechanism must provide certain information that shows the goods or services of interest can be traded under Newton accounts.  Besides the notion of Existence and Ownership, physical assets are further divided into two broad categories, often called: Movable/Personal and Immovable/Real Estate Properties. These asset terms are commonly used in legal and accounting practice, and will be adopted by NPA\u0026rsquo;s namespace management. However, under the accounting classification of Movable Properties, a special category called Intangible Property such as copyrights, brand names, or patents, are not considered a subclass of NPA. Intangible Property is to be classified as subclasses of Named Asset in the inheritance hierarchy of NEAT data types.\nAbstract #  Newton Physical Asset (NPA) is the base asset class that uses executable contract to guarantee the existence and ownership rights of physical assets. Knowing that the cybernetic world and the physical world could exist discrepancies, NPA attempts to approximate the existence and ownership proofs using a combination of four things: Proof of Stake, Soundness Analysis, Precision Analysis, and Time-bound Proofs. These four strategies of proving ownership and existence of physical goods provide a negotiation platform for all Newton account owners to engage with transactions. The design and evolution of NPA will follow the concepts originally developed in property law[1], where the basic rights associated with properties are broadly classified as: Rights to possession, use, manage, income generated, capital, and transmissibility. These rights applies to all assets, including non-physical assets. For NPA specific asset classes, Movable and Immovable assets are distinguished. Then, within Movable Assets, Consumable, Durable, and Interest Generating assets are classified. Within Immovable Assets, Owned and Leased Assets are the two main classes. These classifications are designed to offer time-based distinctions of relationships between assets and accounts.\nMotivation #  The key idea in NPA is to establish provable relationships between accounts and the physical piece of assets. NPA\u0026rsquo;s main design motivation is to leverage the cryptographically-protected account system with a trust-worthy timestamp data service and existing proof of stake insurance policies to secure NPA related transactions. In other words, the key idea of NPA is to unify the overarching framework rooted in NEAT. NPA helps to reduce costs of negotiation by introducing automated reasoning mechanisms about the claims of existence and ownership through Soundness Proofs, Precision Assessment[4], and Newton\u0026rsquo;s secure timestamp system.\nReuse Code by Sharing Expertise across the Supply Chain Management Industry #  Instead of requiring all NPA issuers to learn formal methods and speak in terms of Soundness, Precision, and time security. NPA will work with the standard vocabulary established in the supply chain industry, and primarily focus on proof mechanisms that are related to existence and ownership proofs. By translating the vocabulary from technical domains to supply chain domain, we can separate the work between the two professions. NPA issuers can search for existence and ownership proof in their business specific requirement language, and relevant soundness and precision reasoning mechanisms will be categorized in business terms to help NPA issuers to customize and compose existing executable code to support their needs. Once a new set of executable \u0026ldquo;smart\u0026rdquo; contract has been tested and proven to work in the marketplace with live data, the code can be shared to similar business practices across the Newton Community. Therefore, it is crucial to keep an abstract vocabulary to describe NPA, so that code reuse can be maximized.\nUser Interface for NPA #  When exchanging physical goods, buyers and sellers are likely to perform both sending and receiving roles interchangeably. A reason for the bi-directional sending and receiving functions on both buyer and seller sides is because physical goods might be returned or send back for repair or replacement. Therefore a set of user interfaces that define existence and ownership with precise time bounds on both ends become a significant driver in broadening user base.\nThe strategy for designing user interface of NPA is to insure that roles of sending and receiving are categorized into a set of functional specifications, so that the \u0026ldquo;skin\u0026rdquo; of the user interfaces can be attached to those standardized functional specifications interchangeably. By defining a set of generally applicable functional specifications for delivery and reception verification, NPA will be relatively easy to target many application contexts without having to reinvent the wheels everytime a new, but similar business model is created. This will also help Newton Community to reach a larger community base within a shorter amount of time.\nNon-repudiation Features #  Once certain physical goods are delivered or received, it is necessary to make sure that senders and receivers will not repudiate their reception or sending status. To minimize these possible information conflicts, repudiation resolution process should be designed as a measurable cost component, so that anyone who decides to go through a repudiation process, the system will automatically assign risk factors to parties who breached the repudiation contracts.\nNPA knowledge as a source of income #  Any vendors or buyers submitting bug reports or prescribe solutions to any of the above mentioned problems, will be automatically given credits or be rewarded of their contribution. The more of their cases being adopted and used as a resolution for future cases, the more credit they will receive. Buying and consuming as actions, will naturally accumulate operational data, and data can provide information and potential wisdom to better refine the overall framework of physical good exchange. An explicit reward mechanism will incentivize participants to actively contribute their intellect to help build up a better NPA transaction rule base.\nSpecification #  NPA should use NEAT as the basis of transaction model, which implicitly leverages secure timestamping services built-in Newton Infrastructure. Then, all physical goods must work with Newton Asset Namespace (NAM), so that a unifying namespace could be leveraged to reference known types of physical goods.\nThe existence and ownership status of physical items, should be bounded to existing industry standards or publicly verifiable data sources. Each of these existence and data precision qualities should be bounded to version controlled automatic analytical algorithms that defines the soundness and precision claims. Unless these self-administrating features are provided, no NPA should be issued.\nSyntax and Semantics #  The data structure and the meaning of transactional physical items should also be defined using ideas derived from pi-Calculus. This section inherits all features of NEAT, with the additional records that defines existence and ownership statuses.\n   Syntax Semantics     Account names: (Issuing Account)+ \u0026ldquo;:\u0026rdquo; (Receiving Accounts)+ The direction of asset right transfer: Issuing Accounts -\u0026gt; Receiver Accounts   Asset IDs : (Asset ID)* \u0026ldquo;:\u0026rdquo; (Asset ID)* The first set of (Asset ID)* provides asset to be transferred to Receivers' (Asset ID)*   Time Slots: (Newchain timestamp)+ A sequence of timepoints of actual transactional events marked by (Newchain timestamp)+   Conditions: (Deliver Condition)+ \u0026lsquo;:\u0026rsquo; (Reception Condition)+ (Deliver Condition)+ \u0026lsquo;:\u0026rsquo; (Reception Condition)+ are two set of rules that defines the delivery and reception conditions of asset right transfer. Maybe associated with timestamp information shown in (3).   Comment Field: (Natural Language content that describes the contract) A field dedicate for human understanding, like the Ricardian Contract. The comments of NEAT can be written in a formatted template, the format could follow Logic Model.   Collateral Asset: (Asset ID)+ Collateral asset as a guarantee for participants of this transaction. This is usually defined by the insurance policy for the amount of resources to be issued to participants when transactions failed. (Asset ID)+ should be a set of transferrable assets that will be distributed in case the transaction fails. Initially, this can be certain amount of Newtons made available to insure the risk coverage of possible transaction failure modes.   Reimbursement Rules: (Rule for Reimbursement)+ A contract explicitly defines how to reimburse the participants when the transaction failed to work. The allocation of funds should be independent of the creator of this NEAT type. (Rule for Reimbursement)+: An automated executable contract, written in scripts that would allocate the available cryptographically ensured funds to participants according to various deliver/reception status. The creator of the executable contract should demonstrate that they are NOT in positions of conflict of interest.   Existence : (Rule for existence)+, (identity of physical item), (existence status) A list of rules stating how to judge the existence of certain name-identified physical item, in a set of defined existence status. (Assessment of Existence)+: A set of Soundness and Precision assessment algorithms defined in executable formats in Newton Infrastructure.   Ownership status: (Owner Account)+, (Rule for ownership status)+ A list of rules that defines the owners' identity, and a their ownership status of the above mentioned physical items in the existence field. (Assessment of Ownership)+: A set of Soundness and Precision assessment algorithms that can automatically check ownership status of the mentioned physical items in Newton Infrastructure.    Interaction / Functions #     Function Description Behaviors/Properties     Receivers Add Issuing Account to the collection of accounts that can create and modify the executable contract in the form of NEAT. permission: owner   Senders transfer owner of this executable contract to other Newton Accounts permission: owner   CreateNewToken Create a new instance of NEAT token from this contract    AddMemberBySubscribe Add participating members to the collection of Newton accounts that can transfer or receive data representable assets in the specification defined by NEAT. permission: contract   RemoveMember Remove participating members permission: owner/admin   Initiate Transaction Initiate transaction based on contractual conditions. permission: contract   Exit Transaction Terminate Transaction based on contractual conditions. permission: contract    Rationale #  The transactions of digitally representable assets can be best illustrated by the four fundamental rights as explained by Richard Stallman\u0026rsquo;s \u0026ldquo;Free Software, Free Society\u0026rdquo;[ available here].\n   Free Software pi-Calculus Concept     The right to use Software The choice to engage certain interactive process (Human choose to use certain piece of software)   The right to understand the working mechanisms of Software Parallel execution of the software, including mirror the understanding of the working principles   The right to modify the software for other Uses Change the software in ways that covers the way it didn\u0026rsquo;t work before (Prohibit or enable certain new functions)   The right to re-distribute the modified Software Replicate the software/data asset in alternative distribution channels (Re-distribution for profit)    Leveraging the fundamental rights to the four composable rules, one can define a way to cover a wide range of data asset transaction scenarios that have been investigated for decades by prior luminaries, such as Richard Stallman, Robin Milner, and Leslie Lamport.\nBackwards Compatibility #  All NEPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The NEP must explain how the author proposes to deal with these incompatibilities. NEP submissions without a sufficient backwards compatibility treatise may be rejected outright.\nTest Cases #  All test cases of NEAT should be classified into two kinds:\n Safety tests: examining conditions for when the contract execution will not cause undesirable situations. Liveness tests: examining conditions for when contract execution will ensure something desirable would actually happen.  The safety and liveness tests should be created based on tools such as Static Analysis and TLA+ and other similar test case generation tools.\nTest cases for NEAT should first be conducted on dedicated Newton Test Chain, so that the compatibility of the system could be managed between the two systems.\nSecurity Considerations #  Every NEAT type should be a totally isolated container of its own risks. Every subtype of NEAT will define an equivalent class of risk as measured by our Control Plane. Therefore, the assets associated with the NEAT type should be defined as a bounded liability, so that its risk factors are isolated from the other parts of Newton infrastructure.\nThe Mechanisms of Proofs #  With modern Internet of Things (IoT) Infrastructure, many physical goods and services can attain multi-party, or independent sources of existence proof or ownership proof. Massively manufactured online sensors and actuators usually come with a Media Access Control Address (MAC address), these kind of information can provide the unique identities and locations of information validity. Couple with a distributed timestamp, which will be provided by Newchain, a time-bound security mechanism can be established to validate the proof. In NPA, we suggest the use of static analysis techniques, such as Abstract Interpretation [ 1] to perform Soundness and Precision Analysis. The notion of Soundness and Precision must be interpreted abstractly, meaning that the quality of NPA should be judged by how well the NPA presents \u0026ldquo; sound\u0026rdquo; judgement and \u0026ldquo;precise\u0026rdquo; approximation [ 2], as defined in static analysis tools, independent from the concrete execution of product transaction activities. All subclasses of NPA should follow the Soundness and Precision definition presented in this document, so that every NPA\u0026rsquo;s risk profile can be assessed based on these formally defined characteristics.\nEvery sub class of NEAT must go through a rigorous process to demonstrate that risks are divided into explicitly defined namespaces. The technical term is called identifying \u0026ldquo;Behavioral Equivalence\u0026rdquo;. Assets that can be exchanged through the same kind of transactional mechanisms, should use the same \u0026ldquo;class\u0026rdquo; of NEAT contract. The security features of each NEAT contract should be proven through the software development process. Certain anecdotal thinking can be found in Steiner\u0026rsquo;s blog entry[ 5]. However, to reach a more rigorous level of security, NEAT should try to prove and approve every new subclass following formal methods as described in Rosu\u0026rsquo;s paper: [6]. Rosu also leads the K Framework development, which is a rewrite-based language design model that can be used to define and verify formal properties of languages, such as security related properties. The working mechanism of proofs are managed in a namespace known as types of NEAT, so that all risk factors can be first reasoned in the categories, or types of risks, before committing to real world applications.\nReferences #    Alison Clarke, Paul Kohler, Property Law: Commentary and Materials, Cambridge University Press, 2006\n   Alex Pentland, Alexander Lipton, and Thomas Hardjono, Building the New Economy, MIT Press\n   Patrick Cousot, Abstract Interpretation, Website\n  Bertrand Meyer, Soundness and Completeness: With Precision, Blog@CACM, April 20, 2019, Web, Web\n  Copyright #  Copyright and related rights waived via CC BY-SA 4.0.\n"});index.add({'id':15,'href':'/neps-preview/neps/nep-0024.html','title':"Newton Pre-paid Card (NPC)",'content':"Simple Summary #  Newton Pre-paid Card (NPC) is a cryptographically insured asset that works with exchangeable assets within the Newton Community. It can be extended to issue Membership Card, Score Cards, or even Balanced Score Cards. It can also possess negotiating powers in attaining tangible goods. For example, one may pre-pay for editable goods, such as vegetable, milk, or beef, or other kinds of commercially viable goods. The basic assumptions about NPC is that it provides a classification scheme to define goods. The two immediate categories are Membership Cards and Tangible Goods. These two classes are both sub-classes of Pre-Paid Card. The remaining subdivisions can be visualized in the following Class Diagram.\nAbstract #  Newtoin Pre-paid Card (NPC), is a divisible asset type that can be used to claim rights to group membership, or to claim ownership to tangible goods. The classification of rights should follow certain programmable contracts. NPC as an asset type is to serve as a template for many other classes of assets. Therefore, the development of NPC is not about operating a particular membership or selling tangible goods, it is about providing a general asset classification guideline to use a smaller common base classes to handle many cases of asset transaction for its sub-classes of goods and services. On the other hand, the purpose of NPC is to help Newton Community to best reuse data management technologies and mechanisms for asset transactions. For example, due to practical needs and regulatory concerns, there should be a certain difference in managing edible goods vs. non-edible goods. Therefore, there should be a publicized set of asset classes, encoded as two subclass branches. By explicitly managing the types of various contracts, Newton Infrastructure can better support the whole community to share knowledge in using Newton Community\u0026rsquo;s trust-worthy computing infrastructure. Initially, NPC assumes a single-inherentance class structure. Common interfaces between two non-directly inheritance branches can share APIs through the \u0026ldquo;interface\u0026rdquo; mechanism.\nThe collateral asset to guarantee values of NPC follows the original policies of NEAT. All Pre-paid Card should not only accept payment from buyers who want to own Newton Pre-paid Card, every NPC should come with an insurance policy that have a significant amount of collateral asset locked in a re-imbursement pool in case of contract breach conditions.\nMotivation #  The driving force behind NPC is to establish a standarized naming framework for managed assets. Currently, pre-paid good a services are mostly guaranteed by providers' brand recognition and customer\u0026rsquo;s willingness to risk their investment in exchange for advertised discounted prices. This human-trust mechanism basically leaves consumers to bare risks without any guarantee. Through the design of NPC, risks of different types of goods and services can be classified in our naming convention. Overtime, as real operational data reveals battle-ground situations for different types of goods and services, the contracts can evolve accordingly to capture the operational experience as learned data. It is crucial to emphasize that the Newton Technical Commitee is about designing a reusable framework to best support efficient business practices, it is not about operating actual services and good delivery. This position distinguishes the system design from profit making to community supporting. NPC wants as many types of membership groups, various kinds and large amounts of tangible goods to be bought and sold on the Newton Platform, so that all technical decisions for NPC must be vendor neutral.\nSpecification #  NPC is a subtype of NEAT, so that it will automatically inherit all the features of NEAT. The unique feature of NPC, is in its name, the notion of customer pre-payments. In other words, a significant amount of commercial risk is being shared by customers who pay ahead of time. To become eligible as an issuer of NPC, creator of NPC must demonstrate that they have the ability to deliver the announced services and goods. This process is almost identical to the process of \u0026ldquo;crowd funding\u0026rdquo;. Therefore, the qualification procedure that reveals the capabilities of potential capabilities of NPC issuer is the basis of NPC.\nFor service providers, such as club membership NPC issuer, history or proposed services must be articulated and presented as a part of the process to propose an NPC. Similarly, product providers should illustrate the types, qualities, and quantities of goods that certain vendor is capable of providing, so that they can offer to sell pre-paid cards. From NPC\u0026rsquo;s technical viewpoint, NPC\u0026rsquo;s nature is a publishing service for vendors to reveal their goods and services. The main security features of NPC is to show that all data concerning goods and services are irrefutably presented by the receiver of pre-paid assets. Establishing a content submission and account receivable channel, and make sure that both customers and vendors know that Newton only provides an irrefusable communication channel is the technical scope of NPC. In other words, NPC is not about designing a crowd funding website, NPC is about creating a irrefuable proof mechanism between vendors and potentially pre-paying customers. The focus of NPC is the security mechanism, not the product/service specific functionality.\nBeside focusing on security and irrepudiability, NPC also needs to provide guidelines to explain how to classified goods and services. Membership Cards often defines a given duration to service access, while Tangible Goods often defines rights to claim ownership. The technical focus of NPC is to show that each type of services and products might need a slightly different composition of verification API. For example, Membership Cards might need a time-based API, for verifying the validity of services. Where Tangible Goods might need an inventory checking API to see if certain goods are still available or not. These kinds of differences defines the types, so that NPC can give a common classification to different composition of status verification API. By offering a meaningful classification structure, more people can use NPC.\nSyntax and Semantics #  Here, pi-Calculus will play a major role in defining these interactions. For example, Membership Card would define a set of conditions, that illustrates the four basic components of:\n Choice of service package. Each given a name Parallel composition of service tracks Refusal or Prevention of certain services or event from occurence, (i.e. Non-Smoking) Replication of service Stopping of service.  By defininig a general set of service names, all Membership Cards can use the same vocabulary to define their service terms, so that Newton Infrastructure can be the technical provider of these service negotiation data, not the guarantor of these services.\nThe same syntax and semantics works for Tangible Goods. For example:\n Choice of products and amount defined by units and names of products Parallel composition of Product Delivery Refusal to certain products given certain composition. Replication of Products. Terminating product ownership status.  A set of programming interface will be defined for each of the two main subclasses, and all other services and products will follow this template to define other contracts.\nRationale #  NPC being a financial instrument, it must have some grounding rule to be acceptable by the broadest possible audience. The key idea is the notion of equality, to be explained in the term: Univalent Principle.\nUnivalent Foundation #   Univalent Foundation is a type-based mechanism to identify equivalence. Since data security and system integrity is achieved under a common transaction processing language NEAT, every NPC here is a type of transaction, and every instance of transaction should follow the same set of constraining rules. That gives a \u0026ldquo;equivalent\u0026rdquo; kind of fairness to all transaction. Having said that, it means all NPCs must strive to demonstrate certain objective fairness and security through its design. A starting point is to deposit certain amount of asset that reaches publicly agreements, then, all transactions can happen given that insurance asset is available to guarantee fairness. Other forms of fairness should be provided and tested prior to a release of any NPC. The reason being that any breached contract could cause significant social and economical damage to the system, therefore, a unifying safety procedure must be presented and followed for all systems.\nNPC\u0026rsquo;s unique functions #  NPC differs from other transactions in a sense that services and products are not directly controllable by the Newton Infrastructure. Therefore, the risks that incurred here must be somehow contained within the boundaries of the vendor that created their brand of NPC. The total amount of assets to be offered in exchange of pre-payments must have certain Univalent Principles to be automatically checked by the system. Otherwise, it would render the system to carry the risks for the NPC offering vendors, that is clearly not feasible.\nTherefore NPC must offer the following guarantee to its customers:\n Certain amount of deposit that ensures customer satisfaction. Minimal amount of deposit must fulfill conditions of Byzantine Fault Tolerance. Complete certain testing cycles before releasing to the public. Testing cycle will collect operational data, and this data must be revealed to its potential customers. NPC should have a screening procedure for its customers. Customers who is willing to participate must demonstrate certain level of data literacy before they are allowed to issue the initial down payment. Customers who enter the NPC agreements should agree to the reimbursement strategies prior to participation, so that potential conflicts can be minimized. All subtypes of NPC should strictly follow this agreement, otherwise, we will not be able to achieve Univalence, therefore breaching the system correctness assumptions as shown in NEAT.  Deployment Concerns #  The proper way of seeing NPC is to think of it as a class of financial future. It provides an abstract mechanism to allow vendors to receive payment prior to delivery of services or goods. This time difference is a privilege, and therefore will induce risks on customers. Newton\u0026rsquo;s technology infrastructure is to provide vendors who deserve this opportunity to issue a financial future, while offer a technological platform to inform customers of risks at the earliest possible times.\nReferences #    Leslie Lamport, Time, Clocks, and the Ordering of Events in a Distributed System, Communications of the ACM, July, 1978.\n  Robin Milner, The Polyadic Pi-Calculus a Tutorial, October, 1991\n  Copyright #  Copyright and related rights waived via CC BY-SA 4.0.\n"});index.add({'id':16,'href':'/neps-preview/neps/nep-0007.html','title':"Non-Fungible Token Standard (NRC-7)",'content':"Simple Summary #  A standard interface for non-fungible tokens, also known as deeds.\nAbstract #  The following standard allows for the implementation of a standard API for NFTs within smart contracts. This standard provides basic functionality to track and transfer NFTs.\nWe considered use cases of NFTs being owned and transacted by individuals as well as consignment to third party brokers/wallets/auctioneers (“operators”). NFTs can represent ownership over digital or physical assets. We considered a diverse universe of assets, and we know you will dream up many more.\nMotivation #  A standard interface allows wallet/broker/auction applications to work with any NFT on Ethereum. We provide for simple smart contracts as well as contracts that track an arbitrarily large number of NFTs. Additional applications are discussed below.\nThis standard is inspired by the ERC-721 token standard.\nSpecification #  Meta Data #     Item Description Behaviors/Properties     name A descriptive name for a collection of NFTs in this contract can not be changed   symbol An abbreviated name for NFTs in this contract can not be changed   tokenURI A distinct Uniform Resource Identifier (URI) for a given asset    owner contract deployer, mint NFTs     Interaction / Functions / Event #     Function Description Behaviors/Properties     mint mint a new token permission: owner   transferOwnership Transfers ownership of the contract to a new account (newOwner) permission: owner   transferFrom Transfer ownership of an NFTs permission: current owner, an authorized operator, or the approved address for this NFT   safeTransferFrom Transfers the ownership of an NFT from one address to another address permission: current owner, an authorized operator, or the approved address for this NFT   approve Change or reaffirm the approved address for an NFT permission: NFT owner   setApprovalForAll Enable or disable approval for a third party (\u0026ldquo;operator\u0026rdquo;) to manage all of msg.sender\u0026rsquo;s assets    Query     balanceOf Count all NFTs assigned to an owner    ownerOf Find the owner of an NFT    getApproved Get the approved address for a single NFT    isApprovedForAll Query if an address is an authorized operator for another address    Event     OwnershipTransferred ownership of the contract to a new account    Transfer This emits when ownership of any NFT changes by any mechanism    Approval This emits when the approved address for an NFT is changed or reaffirmed    ApprovalForAll This emits when an operator is enabled or disabled for an owner     Test Cases #  TBD\nImplementation #  interface INRC7 { /** * @dev Emitted when `tokenId` token is transfered from `from` to `to`. */ event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); /** * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token. */ event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); /** * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets. */ event ApprovalForAll(address indexed owner, address indexed operator, bool approved); /** * @dev Emitted when ownership of the contract to a new account (`newOwner`). */ event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev Returns the number of tokens in ``owner``\u0026#39;s account. */ function balanceOf(address owner) external view returns (uint256 balance); /** * @dev Returns the owner of the `tokenId` token. * * Requirements: * * - `tokenId` must exist. */ function ownerOf(uint256 tokenId) external view returns (address owner); /** * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients * are aware of the ERC721 protocol to prevent tokens from being forever locked. * * Requirements: * * - `from`, `to` cannot be zero. * - `tokenId` token must exist and be owned by `from`. * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}. * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. * * Emits a {Transfer} event. */ function safeTransferFrom(address from, address to, uint256 tokenId) external; /** * @dev Transfers `tokenId` token from `from` to `to`. * * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible. * * Requirements: * * - `from`, `to` cannot be zero. * - `tokenId` token must be owned by `from`. * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. * * Emits a {Transfer} event. */ function transferFrom(address from, address to, uint256 tokenId) external; /** * @dev Gives permission to `to` to transfer `tokenId` token to another account. * The approval is cleared when the token is transferred. * * Only a single account can be approved at a time, so approving the zero address clears previous approvals. * * Requirements: * * - The caller must own the token or be an approved operator. * - `tokenId` must exist. * * Emits an {Approval} event. */ function approve(address to, uint256 tokenId) external; /** * @dev Returns the account approved for `tokenId` token. * * Requirements: * * - `tokenId` must exist. */ function getApproved(uint256 tokenId) external view returns (address operator); /** * @dev Approve or remove `operator` as an operator for the caller. * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller. * * Requirements: * * - The `operator` cannot be the caller. * * Emits an {ApprovalForAll} event. */ function setApprovalForAll(address operator, bool _approved) external; /** * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`. * * See {setApprovalForAll} */ function isApprovedForAll(address owner, address operator) external view returns (bool); /** * @dev Safely transfers `tokenId` token from `from` to `to`. * * Requirements: * * - `from`, `to` cannot be zero. * - `tokenId` token must exist and be owned by `from`. * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. * - If `to` refers to a smart contract, it must implement {INRC7Receiver-onNRC7Received}, which is called upon a safe transfer. * * Emits a {Transfer} event. */ function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external; /** * @dev Transfers ownership of the contract to a new account (`newOwner`). * Can only be called by the current owner. */ function transferOwnership(address newOwner) external; } /** * @title NRC7 token receiver interface * @dev Interface for any contract that wants to support safeTransfers * from NRC7 asset contracts. */ interface INRC7Receiver { /** * @notice Handle the receipt of an NFT * @dev The NRC7 smart contract calls this function on the recipient * after a {INRC7-safeTransferFrom}. This function MUST return the function selector, * otherwise the caller will revert the transaction. The selector to be * returned can be obtained as `this.onNRC7Received.selector`. This * function MAY throw to revert and reject the transfer. * Note: the NRC7 contract address is always the message sender. * @param operator The address which called `safeTransferFrom` function * @param from The address which previously owned the token * @param tokenId The NFT identifier which is being transferred * @param data Additional data with no specified format * @return bytes4 `bytes4(keccak256(\u0026#34;onNRC7Received(address,address,uint256,bytes)\u0026#34;))` */ function onNRC7Received(address operator, address from, uint256 tokenId, bytes memory data) public external returns (bytes4); } References #   ERC-721 Token Standard. https://eips.ethereum.org/EIPS/eip-721  Copyright #  Copyright and related rights waived via CC0.\n"});index.add({'id':17,'href':'/neps-preview/neps/nep-0019.html','title':"Physical Commodity Standard (NRC-19)",'content':"Simple Summary #  A standard interface for Physical Commodity token\nAbstract #  This template mainly uses the block chain encryption and non tampering features to verify the ownership, capital flow, receipt confirmation and other information of the physical Commodity involved in the production and circulation process, and synthesizes the information flow, capital flow and logistics flowing in the whole process of raw material suppliers, producers, channel agents, dealers and consumers through the block chain technology There is a sound system of credit value flow. The traditional production, supply and marketing system, which focuses on logistics and capital flow, is upgraded to the supply chain credit system, which solves the credit construction problem of physical Commodity in the process of production and circulation, and realizes the traceability and tracking of goods.\nFrom manufacturing to circulation, the essence of commodities is the process of continuous interaction and confirmation among raw material suppliers, manufacturers, channel agents, distributors and consumers of information flow, capital flow and logistics, and the core of which is the supply chain system. Efficient lubrication of the supply chain system will greatly reduce the time cost and capital cost of enterprises, and improve the production efficiency of enterprises. To achieve such an efficient and lubricated supply chain system, the key is to establish a supply chain credit system, which is the key to improve production efficiency and capital efficiency, and reduce production, logistics and storage costs. The traditional solution mainly depends on the contract signed by all parties, so the contract becomes the core element for the related parties to confirm the ownership and income. The tamperable blockchain technology makes it possible to create a new paradigm of credit system under the condition of new technology. A complete blockchain credit system includes not only the individual credit of each industrial subject (such as legal registration, compliance operation, quality certification system, bank credit, etc.), but also the business reputation established by upstream and downstream manufacturers in the supply chain in the actual business cooperation, which can be fully reflected in the blockchain and cannot be tampered with.\nMotivation #  There are mainly two stages in the process of commodity from scratch to consumers' purchase.\nThe first stage is the production stage, mainly from raw materials to production, to channel agents or distributors. The main problem in this stage is the supply chain, and the core body is the producer. Specifically, it includes the long period of signing the manufacturer\u0026rsquo;s contract (purchase of raw materials and sales to channel agents or distributors), the uncertainty of the time when raw materials are transported to the factory, the high cost of raw materials storage, and the large capital pressure.\nThe second stage is the circulation stage, and the core body is channel agents or distributors, who directly face individual consumers. Their main problems are that they occupy a large amount of capital, have a weak control over capital efficiency and liquidity, and have a high storage cost.\nIn addition, for consumers, it is difficult to have objective and real data to prove the source, quality and value of the purchased Commodity. It is necessary to collect necessary data through the whole traceability system of the Internet of things, and confirm it through the tamperability of the blockchain.\nA credible commodity needs not only reliable raw material supply, but also reliable manufacturers and sellers. In this way, it can not only ensure the high credibility of commodities, but also ensure the credibility of circulation links.\nEach manufacturer or business in the industrial chain is responsible for its own product quality, forming a product credit island. A complete blockchain credit system running through raw material suppliers, producers, channel agents (distributors) and consumers can fundamentally solve the problems concerned by all parties in the industrial chain. Any entity in the industrial chain can confirm its upstream and downstream manufacturers or merchants in the blockchain, realize interactive verification, and then form the blockchain credit system.\nSpecification #  The most important document in the transaction of physical commodity is the purchase contract between the buyer and the seller. The contract will specify the quantity, specification, model, unit price, total price, payment method and other important information of this transaction.\nThe establishment of physical commodity supply chain credit system mainly includes the following attributes.\n  Physical properties ofcommodity: brand, product name, specification and model, production date, warranty period, precautions, etc., especially the relevant data collected through the Internet of things are more authoritative and credible.\n  Manufacturers and merchants: brand, trademark, qualification, process standard, etc.\n  Certification certificate of the third party organization: such as quality management system, safety management system, inspection and test report.\n  Government competent / regulatory authorities: such as industrial and commercial registration documents, tax documents, customs documents, etc\n  According to the role of commodity production and circulation, the subject attribute is defined, and the product or commodity attribute is defined according to the subject.\n  Raw material supplier: sign raw material supply and marketing contract according to the manufacturer\u0026rsquo;s demand order, and provide raw materials with quality and quantity as agreed in the contract. Its main attributes include: Industrial and commercial registration documents, qualification documents, qualification documents, inspection and testing reports, quality assurance system, production standards, management system and main processes. Its raw material properties include: Specification and model, quality inspection report, main technical indicators, precautions, etc. In terms of agricultural products, tea, flowers, fruits and vegetables, the raw material supplier also refers to the main body of breeding, and its main attributes also include the weather data related to temperature, humidity, precipitation, fertilization and irrigation during the breeding process. The data form includes video, which can be real-time or non real-time.\n  Product manufacturer: according to the production plan, sign the raw material supply and marketing contract with the raw material supplier, and pay the corresponding amount to the raw material supplier. According to the needs of channel agents or distributors, sign sales contracts with them, collect payment for commodity and provide goods. Its main attributes include: Industrial and commercial registration documents, qualification documents, qualification documents, inspection and testing reports, quality assurance system, production standards, management system and main processes. Its commodity attributes include: Specification and model, quality inspection report, main technical indicators, precautions, etc.\n  Channel agent or distributor: sign supply and marketing contract with commodity manufacturer, pay for commodity, and promote sales to consumers. Collect payment from consumers and provide them with commodity and services. Its main attributes include: Industrial and commercial registration documents, qualification documents, qualification documents, inspection and testing reports. Its commodity attributes include: Specification and model, quality inspection report, main technical indicators, precautions, etc.; its operation attributes include information of goods on and off the shelf, marketing activities, discounts, points, etc.\n  Logistics service provider: an enterprise that provides logistics services in raw materials, commodities, retail and other links. Its main attributes include: Industrial and commercial registration documents, qualification documents and qualification documents. Its service attributes include data information in the logistics process, such as cargo location information, expected delivery information, transporter information, and, if necessary, temperature, humidity and other information in the vehicle body.\n  Consumers: place orders with dealers, pay for goods and purchase commodity. In addition to personal information, it also includes return and exchange information, payment and refund information, receiving information, complaints, etc.\n  In the process of commodity production and circulation, the core users are producers and channel agents / distributors. With the extension of the supply chain, the ownership of raw materials and commodities will also be transferred with the execution of corresponding contracts. That is to say, a complete and reliable commodity blockchain, in addition to the main physical properties of this commodity, should include the blockchain of raw materials or products of its upstream major suppliers.\nMeta Data #     Item Description Behaviors/Properties     Owner Create Commodity Token    Commodity Commodity Info.：TokenId、Contracts、URL、Partners token: raw material suppliers, manufacturers, channel agents, distributors。     Interaction / Functions #     Function Description Behaviors/Properties     Mint Create Commodity Token permission：Owner   Transfer transfer own to Partners NEW Address permission: Neworg   Get Extension String get extension string data    Set Extension String set extension string data permission: Owner    Rationale (optional) #  The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work, e.g. how the feature is supported in other languages. The rationale may also provide evidence of consensus within the community, and should discuss important objections or concerns raised during discussion.\nBackwards Compatibility (optional) #  All NEPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The NEP must explain how the author proposes to deal with these incompatibilities. NEP submissions without a sufficient backwards compatibility treatise may be rejected outright.\nTest Cases (optional) #  Take the production and sales of new energy vehicles as an example. New energy vehicle manufacturers will have several core suppliers, such as automobile chassis, motor, battery pack and battery management system, automobile glass, etc. The blockchain of new energy vehicles will include its supplier contract, the blockchain of supplier products (automobile chassis, motor, battery pack and battery management system, automobile glass, etc.). The blockchain of new energy vehicles will also be delivered to auto agents or dealers, and finally to consumers.\nImplementation (optional) #  The implementations must be completed before any NEP is given status \u0026ldquo;Final\u0026rdquo;, but it need not be completed before the NEP is accepted. While there is merit to the approach of reaching consensus on the specification and rationale before writing code, the principle of \u0026ldquo;rough consensus and running code\u0026rdquo; is still useful when it comes to resolving many discussions of API details.\nSecurity Considerations #  References #  Copyright #  Copyright and related rights waived via CC0.\n"});index.add({'id':18,'href':'/neps-preview/reviews.html','title':"Reviews",'content':""});})();